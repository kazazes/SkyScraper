// Code generated by Prisma (prisma@1.24.0). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  trunkRecorderConfig: (
    where?: TrunkRecorderConfigWhereInput
  ) => Promise<boolean>;
  trunkRecorderSource: (
    where?: TrunkRecorderSourceWhereInput
  ) => Promise<boolean>;
  trunkRecorderSystem: (
    where?: TrunkRecorderSystemWhereInput
  ) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  trunkRecorderConfigs: (
    args?: {
      where?: TrunkRecorderConfigWhereInput;
      orderBy?: TrunkRecorderConfigOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<TrunkRecorderConfig>;
  trunkRecorderConfigsConnection: (
    args?: {
      where?: TrunkRecorderConfigWhereInput;
      orderBy?: TrunkRecorderConfigOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => TrunkRecorderConfigConnectionPromise;
  trunkRecorderSources: (
    args?: {
      where?: TrunkRecorderSourceWhereInput;
      orderBy?: TrunkRecorderSourceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<TrunkRecorderSource>;
  trunkRecorderSourcesConnection: (
    args?: {
      where?: TrunkRecorderSourceWhereInput;
      orderBy?: TrunkRecorderSourceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => TrunkRecorderSourceConnectionPromise;
  trunkRecorderSystems: (
    args?: {
      where?: TrunkRecorderSystemWhereInput;
      orderBy?: TrunkRecorderSystemOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<TrunkRecorderSystem>;
  trunkRecorderSystemsConnection: (
    args?: {
      where?: TrunkRecorderSystemWhereInput;
      orderBy?: TrunkRecorderSystemOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => TrunkRecorderSystemConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createTrunkRecorderConfig: (
    data: TrunkRecorderConfigCreateInput
  ) => TrunkRecorderConfigPromise;
  updateManyTrunkRecorderConfigs: (
    args: {
      data: TrunkRecorderConfigUpdateManyMutationInput;
      where?: TrunkRecorderConfigWhereInput;
    }
  ) => BatchPayloadPromise;
  deleteManyTrunkRecorderConfigs: (
    where?: TrunkRecorderConfigWhereInput
  ) => BatchPayloadPromise;
  createTrunkRecorderSource: (
    data: TrunkRecorderSourceCreateInput
  ) => TrunkRecorderSourcePromise;
  updateManyTrunkRecorderSources: (
    args: {
      data: TrunkRecorderSourceUpdateManyMutationInput;
      where?: TrunkRecorderSourceWhereInput;
    }
  ) => BatchPayloadPromise;
  deleteManyTrunkRecorderSources: (
    where?: TrunkRecorderSourceWhereInput
  ) => BatchPayloadPromise;
  createTrunkRecorderSystem: (
    data: TrunkRecorderSystemCreateInput
  ) => TrunkRecorderSystemPromise;
  updateManyTrunkRecorderSystems: (
    args: {
      data: TrunkRecorderSystemUpdateManyMutationInput;
      where?: TrunkRecorderSystemWhereInput;
    }
  ) => BatchPayloadPromise;
  deleteManyTrunkRecorderSystems: (
    where?: TrunkRecorderSystemWhereInput
  ) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  trunkRecorderConfig: (
    where?: TrunkRecorderConfigSubscriptionWhereInput
  ) => TrunkRecorderConfigSubscriptionPayloadSubscription;
  trunkRecorderSource: (
    where?: TrunkRecorderSourceSubscriptionWhereInput
  ) => TrunkRecorderSourceSubscriptionPayloadSubscription;
  trunkRecorderSystem: (
    where?: TrunkRecorderSystemSubscriptionWhereInput
  ) => TrunkRecorderSystemSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type TrunkedModulation = "QPSK" | "FSK4";

export type TrunkedSystemType =
  | "SMARTNET"
  | "P25"
  | "CONVENTIONAL"
  | "CONVENTIONAL_P25";

export type SmartnetBandplan =
  | "STANDARD_800"
  | "REBAND_800"
  | "SPLINTER_800"
  | "CUSTOM_400";

export type TalkgroupDisplayFormat = "ID" | "ID_TAG" | "TAG_ID";

export type TrunkRecorderDefaultMode = "ANALOG" | "DIGITAL";

export type TrunkRecorderFrequencyFormat = "EXP" | "MHZ" | "HZ";

export type TrunkRecorderConfigOrderByInput =
  | "defaultMode_ASC"
  | "defaultMode_DESC"
  | "captureDir_ASC"
  | "captureDir_DESC"
  | "callTimeout_ASC"
  | "callTimeout_DESC"
  | "logFile_ASC"
  | "logFile_DESC"
  | "frequencyFormat_ASC"
  | "frequencyFormat_DESC"
  | "controlWarnRate_ASC"
  | "controlWarnRate_DESC"
  | "statusAsString_ASC"
  | "statusAsString_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type TrunkRecorderSourceOrderByInput =
  | "center_ASC"
  | "center_DESC"
  | "rate_ASC"
  | "rate_DESC"
  | "squelch_ASC"
  | "squelch_DESC"
  | "error_ASC"
  | "error_DESC"
  | "gain_ASC"
  | "gain_DESC"
  | "digitalRecorders_ASC"
  | "digitalRecorders_DESC"
  | "digitalLevels_ASC"
  | "digitalLevels_DESC"
  | "analogRecorders_ASC"
  | "analogRecorders_DESC"
  | "analogLevels_ASC"
  | "analogLevels_DESC"
  | "device_ASC"
  | "device_DESC"
  | "modulation_ASC"
  | "modulation_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type TrunkRecorderSystemOrderByInput =
  | "type_ASC"
  | "type_DESC"
  | "talkgroupsFile_ASC"
  | "talkgroupsFile_DESC"
  | "recordUnknown_ASC"
  | "recordUnknown_DESC"
  | "shortName_ASC"
  | "shortName_DESC"
  | "uploadScript_ASC"
  | "uploadScript_DESC"
  | "audioArchive_ASC"
  | "audioArchive_DESC"
  | "callLog_ASC"
  | "callLog_DESC"
  | "bandplan_ASC"
  | "bandplan_DESC"
  | "bandplanBase_ASC"
  | "bandplanBase_DESC"
  | "bandplanHigh_ASC"
  | "bandplanHigh_DESC"
  | "bandplanSpacing_ASC"
  | "bandplanSpacing_DESC"
  | "bandplanOffset_ASC"
  | "bandplanOffset_DESC"
  | "talkgroupDisplayFormat_ASC"
  | "talkgroupDisplayFormat_DESC"
  | "delayCreateOutput_ASC"
  | "delayCreateOutput_DESC"
  | "hideEncrypted_ASC"
  | "hideEncrypted_DESC"
  | "hideUnknownTalkgroups_ASC"
  | "hideUnknownTalkgroups_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export interface TrunkRecorderConfigWhereInput {
  sources_every?: TrunkRecorderSourceWhereInput;
  sources_some?: TrunkRecorderSourceWhereInput;
  sources_none?: TrunkRecorderSourceWhereInput;
  systems_every?: TrunkRecorderSystemWhereInput;
  systems_some?: TrunkRecorderSystemWhereInput;
  systems_none?: TrunkRecorderSystemWhereInput;
  defaultMode?: TrunkRecorderDefaultMode;
  defaultMode_not?: TrunkRecorderDefaultMode;
  defaultMode_in?: TrunkRecorderDefaultMode[] | TrunkRecorderDefaultMode;
  defaultMode_not_in?: TrunkRecorderDefaultMode[] | TrunkRecorderDefaultMode;
  captureDir?: String;
  captureDir_not?: String;
  captureDir_in?: String[] | String;
  captureDir_not_in?: String[] | String;
  captureDir_lt?: String;
  captureDir_lte?: String;
  captureDir_gt?: String;
  captureDir_gte?: String;
  captureDir_contains?: String;
  captureDir_not_contains?: String;
  captureDir_starts_with?: String;
  captureDir_not_starts_with?: String;
  captureDir_ends_with?: String;
  captureDir_not_ends_with?: String;
  callTimeout?: Int;
  callTimeout_not?: Int;
  callTimeout_in?: Int[] | Int;
  callTimeout_not_in?: Int[] | Int;
  callTimeout_lt?: Int;
  callTimeout_lte?: Int;
  callTimeout_gt?: Int;
  callTimeout_gte?: Int;
  logFile?: Boolean;
  logFile_not?: Boolean;
  frequencyFormat?: TrunkRecorderFrequencyFormat;
  frequencyFormat_not?: TrunkRecorderFrequencyFormat;
  frequencyFormat_in?:
    | TrunkRecorderFrequencyFormat[]
    | TrunkRecorderFrequencyFormat;
  frequencyFormat_not_in?:
    | TrunkRecorderFrequencyFormat[]
    | TrunkRecorderFrequencyFormat;
  controlWarnRate?: Int;
  controlWarnRate_not?: Int;
  controlWarnRate_in?: Int[] | Int;
  controlWarnRate_not_in?: Int[] | Int;
  controlWarnRate_lt?: Int;
  controlWarnRate_lte?: Int;
  controlWarnRate_gt?: Int;
  controlWarnRate_gte?: Int;
  statusAsString?: Boolean;
  statusAsString_not?: Boolean;
  AND?: TrunkRecorderConfigWhereInput[] | TrunkRecorderConfigWhereInput;
  OR?: TrunkRecorderConfigWhereInput[] | TrunkRecorderConfigWhereInput;
  NOT?: TrunkRecorderConfigWhereInput[] | TrunkRecorderConfigWhereInput;
}

export interface TrunkRecorderSourceWhereInput {
  center?: Float;
  center_not?: Float;
  center_in?: Float[] | Float;
  center_not_in?: Float[] | Float;
  center_lt?: Float;
  center_lte?: Float;
  center_gt?: Float;
  center_gte?: Float;
  rate?: Float;
  rate_not?: Float;
  rate_in?: Float[] | Float;
  rate_not_in?: Float[] | Float;
  rate_lt?: Float;
  rate_lte?: Float;
  rate_gt?: Float;
  rate_gte?: Float;
  squelch?: Float;
  squelch_not?: Float;
  squelch_in?: Float[] | Float;
  squelch_not_in?: Float[] | Float;
  squelch_lt?: Float;
  squelch_lte?: Float;
  squelch_gt?: Float;
  squelch_gte?: Float;
  error?: Float;
  error_not?: Float;
  error_in?: Float[] | Float;
  error_not_in?: Float[] | Float;
  error_lt?: Float;
  error_lte?: Float;
  error_gt?: Float;
  error_gte?: Float;
  gain?: Float;
  gain_not?: Float;
  gain_in?: Float[] | Float;
  gain_not_in?: Float[] | Float;
  gain_lt?: Float;
  gain_lte?: Float;
  gain_gt?: Float;
  gain_gte?: Float;
  digitalRecorders?: Float;
  digitalRecorders_not?: Float;
  digitalRecorders_in?: Float[] | Float;
  digitalRecorders_not_in?: Float[] | Float;
  digitalRecorders_lt?: Float;
  digitalRecorders_lte?: Float;
  digitalRecorders_gt?: Float;
  digitalRecorders_gte?: Float;
  digitalLevels?: Float;
  digitalLevels_not?: Float;
  digitalLevels_in?: Float[] | Float;
  digitalLevels_not_in?: Float[] | Float;
  digitalLevels_lt?: Float;
  digitalLevels_lte?: Float;
  digitalLevels_gt?: Float;
  digitalLevels_gte?: Float;
  analogRecorders?: Float;
  analogRecorders_not?: Float;
  analogRecorders_in?: Float[] | Float;
  analogRecorders_not_in?: Float[] | Float;
  analogRecorders_lt?: Float;
  analogRecorders_lte?: Float;
  analogRecorders_gt?: Float;
  analogRecorders_gte?: Float;
  analogLevels?: Float;
  analogLevels_not?: Float;
  analogLevels_in?: Float[] | Float;
  analogLevels_not_in?: Float[] | Float;
  analogLevels_lt?: Float;
  analogLevels_lte?: Float;
  analogLevels_gt?: Float;
  analogLevels_gte?: Float;
  device?: String;
  device_not?: String;
  device_in?: String[] | String;
  device_not_in?: String[] | String;
  device_lt?: String;
  device_lte?: String;
  device_gt?: String;
  device_gte?: String;
  device_contains?: String;
  device_not_contains?: String;
  device_starts_with?: String;
  device_not_starts_with?: String;
  device_ends_with?: String;
  device_not_ends_with?: String;
  modulation?: TrunkedModulation;
  modulation_not?: TrunkedModulation;
  modulation_in?: TrunkedModulation[] | TrunkedModulation;
  modulation_not_in?: TrunkedModulation[] | TrunkedModulation;
  AND?: TrunkRecorderSourceWhereInput[] | TrunkRecorderSourceWhereInput;
  OR?: TrunkRecorderSourceWhereInput[] | TrunkRecorderSourceWhereInput;
  NOT?: TrunkRecorderSourceWhereInput[] | TrunkRecorderSourceWhereInput;
}

export interface TrunkRecorderSystemWhereInput {
  type?: TrunkedSystemType;
  type_not?: TrunkedSystemType;
  type_in?: TrunkedSystemType[] | TrunkedSystemType;
  type_not_in?: TrunkedSystemType[] | TrunkedSystemType;
  talkgroupsFile?: String;
  talkgroupsFile_not?: String;
  talkgroupsFile_in?: String[] | String;
  talkgroupsFile_not_in?: String[] | String;
  talkgroupsFile_lt?: String;
  talkgroupsFile_lte?: String;
  talkgroupsFile_gt?: String;
  talkgroupsFile_gte?: String;
  talkgroupsFile_contains?: String;
  talkgroupsFile_not_contains?: String;
  talkgroupsFile_starts_with?: String;
  talkgroupsFile_not_starts_with?: String;
  talkgroupsFile_ends_with?: String;
  talkgroupsFile_not_ends_with?: String;
  recordUnknown?: Boolean;
  recordUnknown_not?: Boolean;
  shortName?: String;
  shortName_not?: String;
  shortName_in?: String[] | String;
  shortName_not_in?: String[] | String;
  shortName_lt?: String;
  shortName_lte?: String;
  shortName_gt?: String;
  shortName_gte?: String;
  shortName_contains?: String;
  shortName_not_contains?: String;
  shortName_starts_with?: String;
  shortName_not_starts_with?: String;
  shortName_ends_with?: String;
  shortName_not_ends_with?: String;
  uploadScript?: String;
  uploadScript_not?: String;
  uploadScript_in?: String[] | String;
  uploadScript_not_in?: String[] | String;
  uploadScript_lt?: String;
  uploadScript_lte?: String;
  uploadScript_gt?: String;
  uploadScript_gte?: String;
  uploadScript_contains?: String;
  uploadScript_not_contains?: String;
  uploadScript_starts_with?: String;
  uploadScript_not_starts_with?: String;
  uploadScript_ends_with?: String;
  uploadScript_not_ends_with?: String;
  audioArchive?: Boolean;
  audioArchive_not?: Boolean;
  callLog?: Boolean;
  callLog_not?: Boolean;
  bandplan?: SmartnetBandplan;
  bandplan_not?: SmartnetBandplan;
  bandplan_in?: SmartnetBandplan[] | SmartnetBandplan;
  bandplan_not_in?: SmartnetBandplan[] | SmartnetBandplan;
  bandplanBase?: Float;
  bandplanBase_not?: Float;
  bandplanBase_in?: Float[] | Float;
  bandplanBase_not_in?: Float[] | Float;
  bandplanBase_lt?: Float;
  bandplanBase_lte?: Float;
  bandplanBase_gt?: Float;
  bandplanBase_gte?: Float;
  bandplanHigh?: Float;
  bandplanHigh_not?: Float;
  bandplanHigh_in?: Float[] | Float;
  bandplanHigh_not_in?: Float[] | Float;
  bandplanHigh_lt?: Float;
  bandplanHigh_lte?: Float;
  bandplanHigh_gt?: Float;
  bandplanHigh_gte?: Float;
  bandplanSpacing?: Float;
  bandplanSpacing_not?: Float;
  bandplanSpacing_in?: Float[] | Float;
  bandplanSpacing_not_in?: Float[] | Float;
  bandplanSpacing_lt?: Float;
  bandplanSpacing_lte?: Float;
  bandplanSpacing_gt?: Float;
  bandplanSpacing_gte?: Float;
  bandplanOffset?: Float;
  bandplanOffset_not?: Float;
  bandplanOffset_in?: Float[] | Float;
  bandplanOffset_not_in?: Float[] | Float;
  bandplanOffset_lt?: Float;
  bandplanOffset_lte?: Float;
  bandplanOffset_gt?: Float;
  bandplanOffset_gte?: Float;
  talkgroupDisplayFormat?: TalkgroupDisplayFormat;
  talkgroupDisplayFormat_not?: TalkgroupDisplayFormat;
  talkgroupDisplayFormat_in?: TalkgroupDisplayFormat[] | TalkgroupDisplayFormat;
  talkgroupDisplayFormat_not_in?:
    | TalkgroupDisplayFormat[]
    | TalkgroupDisplayFormat;
  delayCreateOutput?: Boolean;
  delayCreateOutput_not?: Boolean;
  hideEncrypted?: Boolean;
  hideEncrypted_not?: Boolean;
  hideUnknownTalkgroups?: Boolean;
  hideUnknownTalkgroups_not?: Boolean;
  AND?: TrunkRecorderSystemWhereInput[] | TrunkRecorderSystemWhereInput;
  OR?: TrunkRecorderSystemWhereInput[] | TrunkRecorderSystemWhereInput;
  NOT?: TrunkRecorderSystemWhereInput[] | TrunkRecorderSystemWhereInput;
}

export interface TrunkRecorderConfigCreateInput {
  sources?: TrunkRecorderSourceCreateManyInput;
  systems?: TrunkRecorderSystemCreateManyInput;
  defaultMode?: TrunkRecorderDefaultMode;
  captureDir: String;
  callTimeout?: Int;
  logFile?: Boolean;
  frequencyFormat?: TrunkRecorderFrequencyFormat;
  controlWarnRate?: Int;
  statusAsString?: Boolean;
}

export interface TrunkRecorderSourceCreateManyInput {
  create?: TrunkRecorderSourceCreateInput[] | TrunkRecorderSourceCreateInput;
}

export interface TrunkRecorderSourceCreateInput {
  center: Float;
  rate: Float;
  squelch?: Float;
  error?: Float;
  gain?: Float;
  digitalRecorders?: Float;
  digitalLevels?: Float;
  analogRecorders?: Float;
  analogLevels?: Float;
  device: String;
  modulation: TrunkedModulation;
}

export interface TrunkRecorderSystemCreateManyInput {
  create?: TrunkRecorderSystemCreateInput[] | TrunkRecorderSystemCreateInput;
}

export interface TrunkRecorderSystemCreateInput {
  control_channels?: TrunkRecorderSystemCreatecontrol_channelsInput;
  channels?: TrunkRecorderSystemCreatechannelsInput;
  alphatags?: TrunkRecorderSystemCreatealphatagsInput;
  type: TrunkedSystemType;
  talkgroupsFile?: String;
  recordUnknown?: Boolean;
  shortName: String;
  uploadScript: String;
  audioArchive?: Boolean;
  callLog?: Boolean;
  bandplan?: SmartnetBandplan;
  bandplanBase?: Float;
  bandplanHigh?: Float;
  bandplanSpacing?: Float;
  bandplanOffset?: Float;
  talkgroupDisplayFormat?: TalkgroupDisplayFormat;
  delayCreateOutput?: Boolean;
  hideEncrypted?: Boolean;
  hideUnknownTalkgroups?: Boolean;
}

export interface TrunkRecorderSystemCreatecontrol_channelsInput {
  set?: Float[] | Float;
}

export interface TrunkRecorderSystemCreatechannelsInput {
  set?: Float[] | Float;
}

export interface TrunkRecorderSystemCreatealphatagsInput {
  set?: String[] | String;
}

export interface TrunkRecorderConfigUpdateManyMutationInput {
  defaultMode?: TrunkRecorderDefaultMode;
  captureDir?: String;
  callTimeout?: Int;
  logFile?: Boolean;
  frequencyFormat?: TrunkRecorderFrequencyFormat;
  controlWarnRate?: Int;
  statusAsString?: Boolean;
}

export interface TrunkRecorderSourceUpdateManyMutationInput {
  center?: Float;
  rate?: Float;
  squelch?: Float;
  error?: Float;
  gain?: Float;
  digitalRecorders?: Float;
  digitalLevels?: Float;
  analogRecorders?: Float;
  analogLevels?: Float;
  device?: String;
  modulation?: TrunkedModulation;
}

export interface TrunkRecorderSystemUpdateManyMutationInput {
  control_channels?: TrunkRecorderSystemUpdatecontrol_channelsInput;
  channels?: TrunkRecorderSystemUpdatechannelsInput;
  alphatags?: TrunkRecorderSystemUpdatealphatagsInput;
  type?: TrunkedSystemType;
  talkgroupsFile?: String;
  recordUnknown?: Boolean;
  shortName?: String;
  uploadScript?: String;
  audioArchive?: Boolean;
  callLog?: Boolean;
  bandplan?: SmartnetBandplan;
  bandplanBase?: Float;
  bandplanHigh?: Float;
  bandplanSpacing?: Float;
  bandplanOffset?: Float;
  talkgroupDisplayFormat?: TalkgroupDisplayFormat;
  delayCreateOutput?: Boolean;
  hideEncrypted?: Boolean;
  hideUnknownTalkgroups?: Boolean;
}

export interface TrunkRecorderSystemUpdatecontrol_channelsInput {
  set?: Float[] | Float;
}

export interface TrunkRecorderSystemUpdatechannelsInput {
  set?: Float[] | Float;
}

export interface TrunkRecorderSystemUpdatealphatagsInput {
  set?: String[] | String;
}

export interface TrunkRecorderConfigSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TrunkRecorderConfigWhereInput;
  AND?:
    | TrunkRecorderConfigSubscriptionWhereInput[]
    | TrunkRecorderConfigSubscriptionWhereInput;
  OR?:
    | TrunkRecorderConfigSubscriptionWhereInput[]
    | TrunkRecorderConfigSubscriptionWhereInput;
  NOT?:
    | TrunkRecorderConfigSubscriptionWhereInput[]
    | TrunkRecorderConfigSubscriptionWhereInput;
}

export interface TrunkRecorderSourceSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TrunkRecorderSourceWhereInput;
  AND?:
    | TrunkRecorderSourceSubscriptionWhereInput[]
    | TrunkRecorderSourceSubscriptionWhereInput;
  OR?:
    | TrunkRecorderSourceSubscriptionWhereInput[]
    | TrunkRecorderSourceSubscriptionWhereInput;
  NOT?:
    | TrunkRecorderSourceSubscriptionWhereInput[]
    | TrunkRecorderSourceSubscriptionWhereInput;
}

export interface TrunkRecorderSystemSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TrunkRecorderSystemWhereInput;
  AND?:
    | TrunkRecorderSystemSubscriptionWhereInput[]
    | TrunkRecorderSystemSubscriptionWhereInput;
  OR?:
    | TrunkRecorderSystemSubscriptionWhereInput[]
    | TrunkRecorderSystemSubscriptionWhereInput;
  NOT?:
    | TrunkRecorderSystemSubscriptionWhereInput[]
    | TrunkRecorderSystemSubscriptionWhereInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface TrunkRecorderConfig {
  defaultMode: TrunkRecorderDefaultMode;
  captureDir: String;
  callTimeout: Int;
  logFile: Boolean;
  frequencyFormat: TrunkRecorderFrequencyFormat;
  controlWarnRate: Int;
  statusAsString: Boolean;
}

export interface TrunkRecorderConfigPromise
  extends Promise<TrunkRecorderConfig>,
    Fragmentable {
  sources: <T = FragmentableArray<TrunkRecorderSource>>(
    args?: {
      where?: TrunkRecorderSourceWhereInput;
      orderBy?: TrunkRecorderSourceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  systems: <T = FragmentableArray<TrunkRecorderSystem>>(
    args?: {
      where?: TrunkRecorderSystemWhereInput;
      orderBy?: TrunkRecorderSystemOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  defaultMode: () => Promise<TrunkRecorderDefaultMode>;
  captureDir: () => Promise<String>;
  callTimeout: () => Promise<Int>;
  logFile: () => Promise<Boolean>;
  frequencyFormat: () => Promise<TrunkRecorderFrequencyFormat>;
  controlWarnRate: () => Promise<Int>;
  statusAsString: () => Promise<Boolean>;
}

export interface TrunkRecorderConfigSubscription
  extends Promise<AsyncIterator<TrunkRecorderConfig>>,
    Fragmentable {
  sources: <T = Promise<AsyncIterator<TrunkRecorderSourceSubscription>>>(
    args?: {
      where?: TrunkRecorderSourceWhereInput;
      orderBy?: TrunkRecorderSourceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  systems: <T = Promise<AsyncIterator<TrunkRecorderSystemSubscription>>>(
    args?: {
      where?: TrunkRecorderSystemWhereInput;
      orderBy?: TrunkRecorderSystemOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  defaultMode: () => Promise<AsyncIterator<TrunkRecorderDefaultMode>>;
  captureDir: () => Promise<AsyncIterator<String>>;
  callTimeout: () => Promise<AsyncIterator<Int>>;
  logFile: () => Promise<AsyncIterator<Boolean>>;
  frequencyFormat: () => Promise<AsyncIterator<TrunkRecorderFrequencyFormat>>;
  controlWarnRate: () => Promise<AsyncIterator<Int>>;
  statusAsString: () => Promise<AsyncIterator<Boolean>>;
}

export interface TrunkRecorderSource {
  center: Float;
  rate: Float;
  squelch: Float;
  error: Float;
  gain: Float;
  digitalRecorders: Float;
  digitalLevels?: Float;
  analogRecorders: Float;
  analogLevels?: Float;
  device: String;
  modulation: TrunkedModulation;
}

export interface TrunkRecorderSourcePromise
  extends Promise<TrunkRecorderSource>,
    Fragmentable {
  center: () => Promise<Float>;
  rate: () => Promise<Float>;
  squelch: () => Promise<Float>;
  error: () => Promise<Float>;
  gain: () => Promise<Float>;
  digitalRecorders: () => Promise<Float>;
  digitalLevels: () => Promise<Float>;
  analogRecorders: () => Promise<Float>;
  analogLevels: () => Promise<Float>;
  device: () => Promise<String>;
  modulation: () => Promise<TrunkedModulation>;
}

export interface TrunkRecorderSourceSubscription
  extends Promise<AsyncIterator<TrunkRecorderSource>>,
    Fragmentable {
  center: () => Promise<AsyncIterator<Float>>;
  rate: () => Promise<AsyncIterator<Float>>;
  squelch: () => Promise<AsyncIterator<Float>>;
  error: () => Promise<AsyncIterator<Float>>;
  gain: () => Promise<AsyncIterator<Float>>;
  digitalRecorders: () => Promise<AsyncIterator<Float>>;
  digitalLevels: () => Promise<AsyncIterator<Float>>;
  analogRecorders: () => Promise<AsyncIterator<Float>>;
  analogLevels: () => Promise<AsyncIterator<Float>>;
  device: () => Promise<AsyncIterator<String>>;
  modulation: () => Promise<AsyncIterator<TrunkedModulation>>;
}

export interface TrunkRecorderSystem {
  control_channels: Float[];
  channels: Float[];
  alphatags: String[];
  type: TrunkedSystemType;
  talkgroupsFile?: String;
  recordUnknown?: Boolean;
  shortName: String;
  uploadScript: String;
  audioArchive: Boolean;
  callLog: Boolean;
  bandplan: SmartnetBandplan;
  bandplanBase?: Float;
  bandplanHigh?: Float;
  bandplanSpacing?: Float;
  bandplanOffset?: Float;
  talkgroupDisplayFormat?: TalkgroupDisplayFormat;
  delayCreateOutput?: Boolean;
  hideEncrypted: Boolean;
  hideUnknownTalkgroups: Boolean;
}

export interface TrunkRecorderSystemPromise
  extends Promise<TrunkRecorderSystem>,
    Fragmentable {
  control_channels: () => Promise<Float[]>;
  channels: () => Promise<Float[]>;
  alphatags: () => Promise<String[]>;
  type: () => Promise<TrunkedSystemType>;
  talkgroupsFile: () => Promise<String>;
  recordUnknown: () => Promise<Boolean>;
  shortName: () => Promise<String>;
  uploadScript: () => Promise<String>;
  audioArchive: () => Promise<Boolean>;
  callLog: () => Promise<Boolean>;
  bandplan: () => Promise<SmartnetBandplan>;
  bandplanBase: () => Promise<Float>;
  bandplanHigh: () => Promise<Float>;
  bandplanSpacing: () => Promise<Float>;
  bandplanOffset: () => Promise<Float>;
  talkgroupDisplayFormat: () => Promise<TalkgroupDisplayFormat>;
  delayCreateOutput: () => Promise<Boolean>;
  hideEncrypted: () => Promise<Boolean>;
  hideUnknownTalkgroups: () => Promise<Boolean>;
}

export interface TrunkRecorderSystemSubscription
  extends Promise<AsyncIterator<TrunkRecorderSystem>>,
    Fragmentable {
  control_channels: () => Promise<AsyncIterator<Float[]>>;
  channels: () => Promise<AsyncIterator<Float[]>>;
  alphatags: () => Promise<AsyncIterator<String[]>>;
  type: () => Promise<AsyncIterator<TrunkedSystemType>>;
  talkgroupsFile: () => Promise<AsyncIterator<String>>;
  recordUnknown: () => Promise<AsyncIterator<Boolean>>;
  shortName: () => Promise<AsyncIterator<String>>;
  uploadScript: () => Promise<AsyncIterator<String>>;
  audioArchive: () => Promise<AsyncIterator<Boolean>>;
  callLog: () => Promise<AsyncIterator<Boolean>>;
  bandplan: () => Promise<AsyncIterator<SmartnetBandplan>>;
  bandplanBase: () => Promise<AsyncIterator<Float>>;
  bandplanHigh: () => Promise<AsyncIterator<Float>>;
  bandplanSpacing: () => Promise<AsyncIterator<Float>>;
  bandplanOffset: () => Promise<AsyncIterator<Float>>;
  talkgroupDisplayFormat: () => Promise<AsyncIterator<TalkgroupDisplayFormat>>;
  delayCreateOutput: () => Promise<AsyncIterator<Boolean>>;
  hideEncrypted: () => Promise<AsyncIterator<Boolean>>;
  hideUnknownTalkgroups: () => Promise<AsyncIterator<Boolean>>;
}

export interface TrunkRecorderConfigConnection {
  pageInfo: PageInfo;
  edges: TrunkRecorderConfigEdge[];
}

export interface TrunkRecorderConfigConnectionPromise
  extends Promise<TrunkRecorderConfigConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TrunkRecorderConfigEdge>>() => T;
  aggregate: <T = AggregateTrunkRecorderConfigPromise>() => T;
}

export interface TrunkRecorderConfigConnectionSubscription
  extends Promise<AsyncIterator<TrunkRecorderConfigConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<TrunkRecorderConfigEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateTrunkRecorderConfigSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface TrunkRecorderConfigEdge {
  node: TrunkRecorderConfig;
  cursor: String;
}

export interface TrunkRecorderConfigEdgePromise
  extends Promise<TrunkRecorderConfigEdge>,
    Fragmentable {
  node: <T = TrunkRecorderConfigPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TrunkRecorderConfigEdgeSubscription
  extends Promise<AsyncIterator<TrunkRecorderConfigEdge>>,
    Fragmentable {
  node: <T = TrunkRecorderConfigSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTrunkRecorderConfig {
  count: Int;
}

export interface AggregateTrunkRecorderConfigPromise
  extends Promise<AggregateTrunkRecorderConfig>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTrunkRecorderConfigSubscription
  extends Promise<AsyncIterator<AggregateTrunkRecorderConfig>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TrunkRecorderSourceConnection {
  pageInfo: PageInfo;
  edges: TrunkRecorderSourceEdge[];
}

export interface TrunkRecorderSourceConnectionPromise
  extends Promise<TrunkRecorderSourceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TrunkRecorderSourceEdge>>() => T;
  aggregate: <T = AggregateTrunkRecorderSourcePromise>() => T;
}

export interface TrunkRecorderSourceConnectionSubscription
  extends Promise<AsyncIterator<TrunkRecorderSourceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<TrunkRecorderSourceEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateTrunkRecorderSourceSubscription>() => T;
}

export interface TrunkRecorderSourceEdge {
  node: TrunkRecorderSource;
  cursor: String;
}

export interface TrunkRecorderSourceEdgePromise
  extends Promise<TrunkRecorderSourceEdge>,
    Fragmentable {
  node: <T = TrunkRecorderSourcePromise>() => T;
  cursor: () => Promise<String>;
}

export interface TrunkRecorderSourceEdgeSubscription
  extends Promise<AsyncIterator<TrunkRecorderSourceEdge>>,
    Fragmentable {
  node: <T = TrunkRecorderSourceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTrunkRecorderSource {
  count: Int;
}

export interface AggregateTrunkRecorderSourcePromise
  extends Promise<AggregateTrunkRecorderSource>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTrunkRecorderSourceSubscription
  extends Promise<AsyncIterator<AggregateTrunkRecorderSource>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TrunkRecorderSystemConnection {
  pageInfo: PageInfo;
  edges: TrunkRecorderSystemEdge[];
}

export interface TrunkRecorderSystemConnectionPromise
  extends Promise<TrunkRecorderSystemConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TrunkRecorderSystemEdge>>() => T;
  aggregate: <T = AggregateTrunkRecorderSystemPromise>() => T;
}

export interface TrunkRecorderSystemConnectionSubscription
  extends Promise<AsyncIterator<TrunkRecorderSystemConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<TrunkRecorderSystemEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateTrunkRecorderSystemSubscription>() => T;
}

export interface TrunkRecorderSystemEdge {
  node: TrunkRecorderSystem;
  cursor: String;
}

export interface TrunkRecorderSystemEdgePromise
  extends Promise<TrunkRecorderSystemEdge>,
    Fragmentable {
  node: <T = TrunkRecorderSystemPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TrunkRecorderSystemEdgeSubscription
  extends Promise<AsyncIterator<TrunkRecorderSystemEdge>>,
    Fragmentable {
  node: <T = TrunkRecorderSystemSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTrunkRecorderSystem {
  count: Int;
}

export interface AggregateTrunkRecorderSystemPromise
  extends Promise<AggregateTrunkRecorderSystem>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTrunkRecorderSystemSubscription
  extends Promise<AsyncIterator<AggregateTrunkRecorderSystem>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface TrunkRecorderConfigSubscriptionPayload {
  mutation: MutationType;
  node: TrunkRecorderConfig;
  updatedFields: String[];
  previousValues: TrunkRecorderConfigPreviousValues;
}

export interface TrunkRecorderConfigSubscriptionPayloadPromise
  extends Promise<TrunkRecorderConfigSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TrunkRecorderConfigPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TrunkRecorderConfigPreviousValuesPromise>() => T;
}

export interface TrunkRecorderConfigSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TrunkRecorderConfigSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TrunkRecorderConfigSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TrunkRecorderConfigPreviousValuesSubscription>() => T;
}

export interface TrunkRecorderConfigPreviousValues {
  defaultMode: TrunkRecorderDefaultMode;
  captureDir: String;
  callTimeout: Int;
  logFile: Boolean;
  frequencyFormat: TrunkRecorderFrequencyFormat;
  controlWarnRate: Int;
  statusAsString: Boolean;
}

export interface TrunkRecorderConfigPreviousValuesPromise
  extends Promise<TrunkRecorderConfigPreviousValues>,
    Fragmentable {
  defaultMode: () => Promise<TrunkRecorderDefaultMode>;
  captureDir: () => Promise<String>;
  callTimeout: () => Promise<Int>;
  logFile: () => Promise<Boolean>;
  frequencyFormat: () => Promise<TrunkRecorderFrequencyFormat>;
  controlWarnRate: () => Promise<Int>;
  statusAsString: () => Promise<Boolean>;
}

export interface TrunkRecorderConfigPreviousValuesSubscription
  extends Promise<AsyncIterator<TrunkRecorderConfigPreviousValues>>,
    Fragmentable {
  defaultMode: () => Promise<AsyncIterator<TrunkRecorderDefaultMode>>;
  captureDir: () => Promise<AsyncIterator<String>>;
  callTimeout: () => Promise<AsyncIterator<Int>>;
  logFile: () => Promise<AsyncIterator<Boolean>>;
  frequencyFormat: () => Promise<AsyncIterator<TrunkRecorderFrequencyFormat>>;
  controlWarnRate: () => Promise<AsyncIterator<Int>>;
  statusAsString: () => Promise<AsyncIterator<Boolean>>;
}

export interface TrunkRecorderSourceSubscriptionPayload {
  mutation: MutationType;
  node: TrunkRecorderSource;
  updatedFields: String[];
  previousValues: TrunkRecorderSourcePreviousValues;
}

export interface TrunkRecorderSourceSubscriptionPayloadPromise
  extends Promise<TrunkRecorderSourceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TrunkRecorderSourcePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TrunkRecorderSourcePreviousValuesPromise>() => T;
}

export interface TrunkRecorderSourceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TrunkRecorderSourceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TrunkRecorderSourceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TrunkRecorderSourcePreviousValuesSubscription>() => T;
}

export interface TrunkRecorderSourcePreviousValues {
  center: Float;
  rate: Float;
  squelch: Float;
  error: Float;
  gain: Float;
  digitalRecorders: Float;
  digitalLevels?: Float;
  analogRecorders: Float;
  analogLevels?: Float;
  device: String;
  modulation: TrunkedModulation;
}

export interface TrunkRecorderSourcePreviousValuesPromise
  extends Promise<TrunkRecorderSourcePreviousValues>,
    Fragmentable {
  center: () => Promise<Float>;
  rate: () => Promise<Float>;
  squelch: () => Promise<Float>;
  error: () => Promise<Float>;
  gain: () => Promise<Float>;
  digitalRecorders: () => Promise<Float>;
  digitalLevels: () => Promise<Float>;
  analogRecorders: () => Promise<Float>;
  analogLevels: () => Promise<Float>;
  device: () => Promise<String>;
  modulation: () => Promise<TrunkedModulation>;
}

export interface TrunkRecorderSourcePreviousValuesSubscription
  extends Promise<AsyncIterator<TrunkRecorderSourcePreviousValues>>,
    Fragmentable {
  center: () => Promise<AsyncIterator<Float>>;
  rate: () => Promise<AsyncIterator<Float>>;
  squelch: () => Promise<AsyncIterator<Float>>;
  error: () => Promise<AsyncIterator<Float>>;
  gain: () => Promise<AsyncIterator<Float>>;
  digitalRecorders: () => Promise<AsyncIterator<Float>>;
  digitalLevels: () => Promise<AsyncIterator<Float>>;
  analogRecorders: () => Promise<AsyncIterator<Float>>;
  analogLevels: () => Promise<AsyncIterator<Float>>;
  device: () => Promise<AsyncIterator<String>>;
  modulation: () => Promise<AsyncIterator<TrunkedModulation>>;
}

export interface TrunkRecorderSystemSubscriptionPayload {
  mutation: MutationType;
  node: TrunkRecorderSystem;
  updatedFields: String[];
  previousValues: TrunkRecorderSystemPreviousValues;
}

export interface TrunkRecorderSystemSubscriptionPayloadPromise
  extends Promise<TrunkRecorderSystemSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TrunkRecorderSystemPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TrunkRecorderSystemPreviousValuesPromise>() => T;
}

export interface TrunkRecorderSystemSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TrunkRecorderSystemSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TrunkRecorderSystemSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TrunkRecorderSystemPreviousValuesSubscription>() => T;
}

export interface TrunkRecorderSystemPreviousValues {
  control_channels: Float[];
  channels: Float[];
  alphatags: String[];
  type: TrunkedSystemType;
  talkgroupsFile?: String;
  recordUnknown?: Boolean;
  shortName: String;
  uploadScript: String;
  audioArchive: Boolean;
  callLog: Boolean;
  bandplan: SmartnetBandplan;
  bandplanBase?: Float;
  bandplanHigh?: Float;
  bandplanSpacing?: Float;
  bandplanOffset?: Float;
  talkgroupDisplayFormat?: TalkgroupDisplayFormat;
  delayCreateOutput?: Boolean;
  hideEncrypted: Boolean;
  hideUnknownTalkgroups: Boolean;
}

export interface TrunkRecorderSystemPreviousValuesPromise
  extends Promise<TrunkRecorderSystemPreviousValues>,
    Fragmentable {
  control_channels: () => Promise<Float[]>;
  channels: () => Promise<Float[]>;
  alphatags: () => Promise<String[]>;
  type: () => Promise<TrunkedSystemType>;
  talkgroupsFile: () => Promise<String>;
  recordUnknown: () => Promise<Boolean>;
  shortName: () => Promise<String>;
  uploadScript: () => Promise<String>;
  audioArchive: () => Promise<Boolean>;
  callLog: () => Promise<Boolean>;
  bandplan: () => Promise<SmartnetBandplan>;
  bandplanBase: () => Promise<Float>;
  bandplanHigh: () => Promise<Float>;
  bandplanSpacing: () => Promise<Float>;
  bandplanOffset: () => Promise<Float>;
  talkgroupDisplayFormat: () => Promise<TalkgroupDisplayFormat>;
  delayCreateOutput: () => Promise<Boolean>;
  hideEncrypted: () => Promise<Boolean>;
  hideUnknownTalkgroups: () => Promise<Boolean>;
}

export interface TrunkRecorderSystemPreviousValuesSubscription
  extends Promise<AsyncIterator<TrunkRecorderSystemPreviousValues>>,
    Fragmentable {
  control_channels: () => Promise<AsyncIterator<Float[]>>;
  channels: () => Promise<AsyncIterator<Float[]>>;
  alphatags: () => Promise<AsyncIterator<String[]>>;
  type: () => Promise<AsyncIterator<TrunkedSystemType>>;
  talkgroupsFile: () => Promise<AsyncIterator<String>>;
  recordUnknown: () => Promise<AsyncIterator<Boolean>>;
  shortName: () => Promise<AsyncIterator<String>>;
  uploadScript: () => Promise<AsyncIterator<String>>;
  audioArchive: () => Promise<AsyncIterator<Boolean>>;
  callLog: () => Promise<AsyncIterator<Boolean>>;
  bandplan: () => Promise<AsyncIterator<SmartnetBandplan>>;
  bandplanBase: () => Promise<AsyncIterator<Float>>;
  bandplanHigh: () => Promise<AsyncIterator<Float>>;
  bandplanSpacing: () => Promise<AsyncIterator<Float>>;
  bandplanOffset: () => Promise<AsyncIterator<Float>>;
  talkgroupDisplayFormat: () => Promise<AsyncIterator<TalkgroupDisplayFormat>>;
  delayCreateOutput: () => Promise<AsyncIterator<Boolean>>;
  hideEncrypted: () => Promise<AsyncIterator<Boolean>>;
  hideUnknownTalkgroups: () => Promise<AsyncIterator<Boolean>>;
}

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point). 
*/
export type Float = number;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "SmartnetBandplan",
    embedded: false
  },
  {
    name: "TalkgroupDisplayFormat",
    embedded: false
  },
  {
    name: "TrunkRecorderConfig",
    embedded: false
  },
  {
    name: "TrunkRecorderDefaultMode",
    embedded: false
  },
  {
    name: "TrunkRecorderFrequencyFormat",
    embedded: false
  },
  {
    name: "TrunkRecorderSource",
    embedded: false
  },
  {
    name: "TrunkRecorderSystem",
    embedded: false
  },
  {
    name: "TrunkedModulation",
    embedded: false
  },
  {
    name: "TrunkedSystemType",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `https://us1.prisma.sh/peter-k/skyscraper/dev`
});
export const prisma = new Prisma();
