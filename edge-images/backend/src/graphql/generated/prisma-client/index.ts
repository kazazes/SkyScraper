// Code generated by Prisma (prisma@1.32.0-beta.3). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  dump1090Aircraft: (where?: Dump1090AircraftWhereInput) => Promise<boolean>;
  dump1090Message: (where?: Dump1090MessageWhereInput) => Promise<boolean>;
  transcription: (where?: TranscriptionWhereInput) => Promise<boolean>;
  transcriptionWord: (where?: TranscriptionWordWhereInput) => Promise<boolean>;
  trunkedCall: (where?: TrunkedCallWhereInput) => Promise<boolean>;
  trunkedCallFrequencyTime: (
    where?: TrunkedCallFrequencyTimeWhereInput
  ) => Promise<boolean>;
  trunkedCallSource: (where?: TrunkedCallSourceWhereInput) => Promise<boolean>;
  trunkedConfig: (where?: TrunkedConfigWhereInput) => Promise<boolean>;
  trunkedSource: (where?: TrunkedSourceWhereInput) => Promise<boolean>;
  trunkedSystem: (where?: TrunkedSystemWhereInput) => Promise<boolean>;
  trunkedTalkgroup: (where?: TrunkedTalkgroupWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  dump1090Aircraft: (
    where: Dump1090AircraftWhereUniqueInput
  ) => Dump1090AircraftNullablePromise;
  dump1090Aircrafts: (args?: {
    where?: Dump1090AircraftWhereInput;
    orderBy?: Dump1090AircraftOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Dump1090Aircraft>;
  dump1090AircraftsConnection: (args?: {
    where?: Dump1090AircraftWhereInput;
    orderBy?: Dump1090AircraftOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => Dump1090AircraftConnectionPromise;
  dump1090Message: (
    where: Dump1090MessageWhereUniqueInput
  ) => Dump1090MessageNullablePromise;
  dump1090Messages: (args?: {
    where?: Dump1090MessageWhereInput;
    orderBy?: Dump1090MessageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Dump1090Message>;
  dump1090MessagesConnection: (args?: {
    where?: Dump1090MessageWhereInput;
    orderBy?: Dump1090MessageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => Dump1090MessageConnectionPromise;
  transcription: (
    where: TranscriptionWhereUniqueInput
  ) => TranscriptionNullablePromise;
  transcriptions: (args?: {
    where?: TranscriptionWhereInput;
    orderBy?: TranscriptionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Transcription>;
  transcriptionsConnection: (args?: {
    where?: TranscriptionWhereInput;
    orderBy?: TranscriptionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TranscriptionConnectionPromise;
  transcriptionWord: (
    where: TranscriptionWordWhereUniqueInput
  ) => TranscriptionWordNullablePromise;
  transcriptionWords: (args?: {
    where?: TranscriptionWordWhereInput;
    orderBy?: TranscriptionWordOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<TranscriptionWord>;
  transcriptionWordsConnection: (args?: {
    where?: TranscriptionWordWhereInput;
    orderBy?: TranscriptionWordOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TranscriptionWordConnectionPromise;
  trunkedCall: (
    where: TrunkedCallWhereUniqueInput
  ) => TrunkedCallNullablePromise;
  trunkedCalls: (args?: {
    where?: TrunkedCallWhereInput;
    orderBy?: TrunkedCallOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<TrunkedCall>;
  trunkedCallsConnection: (args?: {
    where?: TrunkedCallWhereInput;
    orderBy?: TrunkedCallOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TrunkedCallConnectionPromise;
  trunkedCallFrequencyTime: (
    where: TrunkedCallFrequencyTimeWhereUniqueInput
  ) => TrunkedCallFrequencyTimeNullablePromise;
  trunkedCallFrequencyTimes: (args?: {
    where?: TrunkedCallFrequencyTimeWhereInput;
    orderBy?: TrunkedCallFrequencyTimeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<TrunkedCallFrequencyTime>;
  trunkedCallFrequencyTimesConnection: (args?: {
    where?: TrunkedCallFrequencyTimeWhereInput;
    orderBy?: TrunkedCallFrequencyTimeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TrunkedCallFrequencyTimeConnectionPromise;
  trunkedCallSource: (
    where: TrunkedCallSourceWhereUniqueInput
  ) => TrunkedCallSourceNullablePromise;
  trunkedCallSources: (args?: {
    where?: TrunkedCallSourceWhereInput;
    orderBy?: TrunkedCallSourceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<TrunkedCallSource>;
  trunkedCallSourcesConnection: (args?: {
    where?: TrunkedCallSourceWhereInput;
    orderBy?: TrunkedCallSourceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TrunkedCallSourceConnectionPromise;
  trunkedConfig: (
    where: TrunkedConfigWhereUniqueInput
  ) => TrunkedConfigNullablePromise;
  trunkedConfigs: (args?: {
    where?: TrunkedConfigWhereInput;
    orderBy?: TrunkedConfigOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<TrunkedConfig>;
  trunkedConfigsConnection: (args?: {
    where?: TrunkedConfigWhereInput;
    orderBy?: TrunkedConfigOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TrunkedConfigConnectionPromise;
  trunkedSource: (
    where: TrunkedSourceWhereUniqueInput
  ) => TrunkedSourceNullablePromise;
  trunkedSources: (args?: {
    where?: TrunkedSourceWhereInput;
    orderBy?: TrunkedSourceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<TrunkedSource>;
  trunkedSourcesConnection: (args?: {
    where?: TrunkedSourceWhereInput;
    orderBy?: TrunkedSourceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TrunkedSourceConnectionPromise;
  trunkedSystem: (
    where: TrunkedSystemWhereUniqueInput
  ) => TrunkedSystemNullablePromise;
  trunkedSystems: (args?: {
    where?: TrunkedSystemWhereInput;
    orderBy?: TrunkedSystemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<TrunkedSystem>;
  trunkedSystemsConnection: (args?: {
    where?: TrunkedSystemWhereInput;
    orderBy?: TrunkedSystemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TrunkedSystemConnectionPromise;
  trunkedTalkgroup: (
    where: TrunkedTalkgroupWhereUniqueInput
  ) => TrunkedTalkgroupNullablePromise;
  trunkedTalkgroups: (args?: {
    where?: TrunkedTalkgroupWhereInput;
    orderBy?: TrunkedTalkgroupOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<TrunkedTalkgroup>;
  trunkedTalkgroupsConnection: (args?: {
    where?: TrunkedTalkgroupWhereInput;
    orderBy?: TrunkedTalkgroupOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TrunkedTalkgroupConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createDump1090Aircraft: (
    data: Dump1090AircraftCreateInput
  ) => Dump1090AircraftPromise;
  updateDump1090Aircraft: (args: {
    data: Dump1090AircraftUpdateInput;
    where: Dump1090AircraftWhereUniqueInput;
  }) => Dump1090AircraftPromise;
  updateManyDump1090Aircrafts: (args: {
    data: Dump1090AircraftUpdateManyMutationInput;
    where?: Dump1090AircraftWhereInput;
  }) => BatchPayloadPromise;
  upsertDump1090Aircraft: (args: {
    where: Dump1090AircraftWhereUniqueInput;
    create: Dump1090AircraftCreateInput;
    update: Dump1090AircraftUpdateInput;
  }) => Dump1090AircraftPromise;
  deleteDump1090Aircraft: (
    where: Dump1090AircraftWhereUniqueInput
  ) => Dump1090AircraftPromise;
  deleteManyDump1090Aircrafts: (
    where?: Dump1090AircraftWhereInput
  ) => BatchPayloadPromise;
  createDump1090Message: (
    data: Dump1090MessageCreateInput
  ) => Dump1090MessagePromise;
  updateDump1090Message: (args: {
    data: Dump1090MessageUpdateInput;
    where: Dump1090MessageWhereUniqueInput;
  }) => Dump1090MessagePromise;
  updateManyDump1090Messages: (args: {
    data: Dump1090MessageUpdateManyMutationInput;
    where?: Dump1090MessageWhereInput;
  }) => BatchPayloadPromise;
  upsertDump1090Message: (args: {
    where: Dump1090MessageWhereUniqueInput;
    create: Dump1090MessageCreateInput;
    update: Dump1090MessageUpdateInput;
  }) => Dump1090MessagePromise;
  deleteDump1090Message: (
    where: Dump1090MessageWhereUniqueInput
  ) => Dump1090MessagePromise;
  deleteManyDump1090Messages: (
    where?: Dump1090MessageWhereInput
  ) => BatchPayloadPromise;
  createTranscription: (data: TranscriptionCreateInput) => TranscriptionPromise;
  updateTranscription: (args: {
    data: TranscriptionUpdateInput;
    where: TranscriptionWhereUniqueInput;
  }) => TranscriptionPromise;
  updateManyTranscriptions: (args: {
    data: TranscriptionUpdateManyMutationInput;
    where?: TranscriptionWhereInput;
  }) => BatchPayloadPromise;
  upsertTranscription: (args: {
    where: TranscriptionWhereUniqueInput;
    create: TranscriptionCreateInput;
    update: TranscriptionUpdateInput;
  }) => TranscriptionPromise;
  deleteTranscription: (
    where: TranscriptionWhereUniqueInput
  ) => TranscriptionPromise;
  deleteManyTranscriptions: (
    where?: TranscriptionWhereInput
  ) => BatchPayloadPromise;
  createTranscriptionWord: (
    data: TranscriptionWordCreateInput
  ) => TranscriptionWordPromise;
  updateTranscriptionWord: (args: {
    data: TranscriptionWordUpdateInput;
    where: TranscriptionWordWhereUniqueInput;
  }) => TranscriptionWordPromise;
  updateManyTranscriptionWords: (args: {
    data: TranscriptionWordUpdateManyMutationInput;
    where?: TranscriptionWordWhereInput;
  }) => BatchPayloadPromise;
  upsertTranscriptionWord: (args: {
    where: TranscriptionWordWhereUniqueInput;
    create: TranscriptionWordCreateInput;
    update: TranscriptionWordUpdateInput;
  }) => TranscriptionWordPromise;
  deleteTranscriptionWord: (
    where: TranscriptionWordWhereUniqueInput
  ) => TranscriptionWordPromise;
  deleteManyTranscriptionWords: (
    where?: TranscriptionWordWhereInput
  ) => BatchPayloadPromise;
  createTrunkedCall: (data: TrunkedCallCreateInput) => TrunkedCallPromise;
  updateTrunkedCall: (args: {
    data: TrunkedCallUpdateInput;
    where: TrunkedCallWhereUniqueInput;
  }) => TrunkedCallPromise;
  updateManyTrunkedCalls: (args: {
    data: TrunkedCallUpdateManyMutationInput;
    where?: TrunkedCallWhereInput;
  }) => BatchPayloadPromise;
  upsertTrunkedCall: (args: {
    where: TrunkedCallWhereUniqueInput;
    create: TrunkedCallCreateInput;
    update: TrunkedCallUpdateInput;
  }) => TrunkedCallPromise;
  deleteTrunkedCall: (where: TrunkedCallWhereUniqueInput) => TrunkedCallPromise;
  deleteManyTrunkedCalls: (
    where?: TrunkedCallWhereInput
  ) => BatchPayloadPromise;
  createTrunkedCallFrequencyTime: (
    data: TrunkedCallFrequencyTimeCreateInput
  ) => TrunkedCallFrequencyTimePromise;
  updateTrunkedCallFrequencyTime: (args: {
    data: TrunkedCallFrequencyTimeUpdateInput;
    where: TrunkedCallFrequencyTimeWhereUniqueInput;
  }) => TrunkedCallFrequencyTimePromise;
  updateManyTrunkedCallFrequencyTimes: (args: {
    data: TrunkedCallFrequencyTimeUpdateManyMutationInput;
    where?: TrunkedCallFrequencyTimeWhereInput;
  }) => BatchPayloadPromise;
  upsertTrunkedCallFrequencyTime: (args: {
    where: TrunkedCallFrequencyTimeWhereUniqueInput;
    create: TrunkedCallFrequencyTimeCreateInput;
    update: TrunkedCallFrequencyTimeUpdateInput;
  }) => TrunkedCallFrequencyTimePromise;
  deleteTrunkedCallFrequencyTime: (
    where: TrunkedCallFrequencyTimeWhereUniqueInput
  ) => TrunkedCallFrequencyTimePromise;
  deleteManyTrunkedCallFrequencyTimes: (
    where?: TrunkedCallFrequencyTimeWhereInput
  ) => BatchPayloadPromise;
  createTrunkedCallSource: (
    data: TrunkedCallSourceCreateInput
  ) => TrunkedCallSourcePromise;
  updateTrunkedCallSource: (args: {
    data: TrunkedCallSourceUpdateInput;
    where: TrunkedCallSourceWhereUniqueInput;
  }) => TrunkedCallSourcePromise;
  updateManyTrunkedCallSources: (args: {
    data: TrunkedCallSourceUpdateManyMutationInput;
    where?: TrunkedCallSourceWhereInput;
  }) => BatchPayloadPromise;
  upsertTrunkedCallSource: (args: {
    where: TrunkedCallSourceWhereUniqueInput;
    create: TrunkedCallSourceCreateInput;
    update: TrunkedCallSourceUpdateInput;
  }) => TrunkedCallSourcePromise;
  deleteTrunkedCallSource: (
    where: TrunkedCallSourceWhereUniqueInput
  ) => TrunkedCallSourcePromise;
  deleteManyTrunkedCallSources: (
    where?: TrunkedCallSourceWhereInput
  ) => BatchPayloadPromise;
  createTrunkedConfig: (data: TrunkedConfigCreateInput) => TrunkedConfigPromise;
  updateTrunkedConfig: (args: {
    data: TrunkedConfigUpdateInput;
    where: TrunkedConfigWhereUniqueInput;
  }) => TrunkedConfigPromise;
  updateManyTrunkedConfigs: (args: {
    data: TrunkedConfigUpdateManyMutationInput;
    where?: TrunkedConfigWhereInput;
  }) => BatchPayloadPromise;
  upsertTrunkedConfig: (args: {
    where: TrunkedConfigWhereUniqueInput;
    create: TrunkedConfigCreateInput;
    update: TrunkedConfigUpdateInput;
  }) => TrunkedConfigPromise;
  deleteTrunkedConfig: (
    where: TrunkedConfigWhereUniqueInput
  ) => TrunkedConfigPromise;
  deleteManyTrunkedConfigs: (
    where?: TrunkedConfigWhereInput
  ) => BatchPayloadPromise;
  createTrunkedSource: (data: TrunkedSourceCreateInput) => TrunkedSourcePromise;
  updateTrunkedSource: (args: {
    data: TrunkedSourceUpdateInput;
    where: TrunkedSourceWhereUniqueInput;
  }) => TrunkedSourcePromise;
  updateManyTrunkedSources: (args: {
    data: TrunkedSourceUpdateManyMutationInput;
    where?: TrunkedSourceWhereInput;
  }) => BatchPayloadPromise;
  upsertTrunkedSource: (args: {
    where: TrunkedSourceWhereUniqueInput;
    create: TrunkedSourceCreateInput;
    update: TrunkedSourceUpdateInput;
  }) => TrunkedSourcePromise;
  deleteTrunkedSource: (
    where: TrunkedSourceWhereUniqueInput
  ) => TrunkedSourcePromise;
  deleteManyTrunkedSources: (
    where?: TrunkedSourceWhereInput
  ) => BatchPayloadPromise;
  createTrunkedSystem: (data: TrunkedSystemCreateInput) => TrunkedSystemPromise;
  updateTrunkedSystem: (args: {
    data: TrunkedSystemUpdateInput;
    where: TrunkedSystemWhereUniqueInput;
  }) => TrunkedSystemPromise;
  updateManyTrunkedSystems: (args: {
    data: TrunkedSystemUpdateManyMutationInput;
    where?: TrunkedSystemWhereInput;
  }) => BatchPayloadPromise;
  upsertTrunkedSystem: (args: {
    where: TrunkedSystemWhereUniqueInput;
    create: TrunkedSystemCreateInput;
    update: TrunkedSystemUpdateInput;
  }) => TrunkedSystemPromise;
  deleteTrunkedSystem: (
    where: TrunkedSystemWhereUniqueInput
  ) => TrunkedSystemPromise;
  deleteManyTrunkedSystems: (
    where?: TrunkedSystemWhereInput
  ) => BatchPayloadPromise;
  createTrunkedTalkgroup: (
    data: TrunkedTalkgroupCreateInput
  ) => TrunkedTalkgroupPromise;
  updateTrunkedTalkgroup: (args: {
    data: TrunkedTalkgroupUpdateInput;
    where: TrunkedTalkgroupWhereUniqueInput;
  }) => TrunkedTalkgroupPromise;
  updateManyTrunkedTalkgroups: (args: {
    data: TrunkedTalkgroupUpdateManyMutationInput;
    where?: TrunkedTalkgroupWhereInput;
  }) => BatchPayloadPromise;
  upsertTrunkedTalkgroup: (args: {
    where: TrunkedTalkgroupWhereUniqueInput;
    create: TrunkedTalkgroupCreateInput;
    update: TrunkedTalkgroupUpdateInput;
  }) => TrunkedTalkgroupPromise;
  deleteTrunkedTalkgroup: (
    where: TrunkedTalkgroupWhereUniqueInput
  ) => TrunkedTalkgroupPromise;
  deleteManyTrunkedTalkgroups: (
    where?: TrunkedTalkgroupWhereInput
  ) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  dump1090Aircraft: (
    where?: Dump1090AircraftSubscriptionWhereInput
  ) => Dump1090AircraftSubscriptionPayloadSubscription;
  dump1090Message: (
    where?: Dump1090MessageSubscriptionWhereInput
  ) => Dump1090MessageSubscriptionPayloadSubscription;
  transcription: (
    where?: TranscriptionSubscriptionWhereInput
  ) => TranscriptionSubscriptionPayloadSubscription;
  transcriptionWord: (
    where?: TranscriptionWordSubscriptionWhereInput
  ) => TranscriptionWordSubscriptionPayloadSubscription;
  trunkedCall: (
    where?: TrunkedCallSubscriptionWhereInput
  ) => TrunkedCallSubscriptionPayloadSubscription;
  trunkedCallFrequencyTime: (
    where?: TrunkedCallFrequencyTimeSubscriptionWhereInput
  ) => TrunkedCallFrequencyTimeSubscriptionPayloadSubscription;
  trunkedCallSource: (
    where?: TrunkedCallSourceSubscriptionWhereInput
  ) => TrunkedCallSourceSubscriptionPayloadSubscription;
  trunkedConfig: (
    where?: TrunkedConfigSubscriptionWhereInput
  ) => TrunkedConfigSubscriptionPayloadSubscription;
  trunkedSource: (
    where?: TrunkedSourceSubscriptionWhereInput
  ) => TrunkedSourceSubscriptionPayloadSubscription;
  trunkedSystem: (
    where?: TrunkedSystemSubscriptionWhereInput
  ) => TrunkedSystemSubscriptionPayloadSubscription;
  trunkedTalkgroup: (
    where?: TrunkedTalkgroupSubscriptionWhereInput
  ) => TrunkedTalkgroupSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type TranscriptionWordOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "text_ASC"
  | "text_DESC"
  | "confidence_ASC"
  | "confidence_DESC"
  | "end_ASC"
  | "end_DESC"
  | "start_ASC"
  | "start_DESC";

export type TrunkedSystemType =
  | "SMARTNET"
  | "P25"
  | "CONVENTIONAL"
  | "CONVENTIONAL_P25"
  | "UNKNOWN";

export type TrunkedCallFrequencyTimeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "frequency_ASC"
  | "frequency_DESC"
  | "time_ASC"
  | "time_DESC"
  | "position_ASC"
  | "position_DESC"
  | "length_ASC"
  | "length_DESC"
  | "errors_ASC"
  | "errors_DESC"
  | "spikes_ASC"
  | "spikes_DESC";

export type TrunkedConfigOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "name_ASC"
  | "name_DESC"
  | "defaultMode_ASC"
  | "defaultMode_DESC"
  | "captureDir_ASC"
  | "captureDir_DESC"
  | "callTimeout_ASC"
  | "callTimeout_DESC"
  | "logFile_ASC"
  | "logFile_DESC"
  | "frequencyFormat_ASC"
  | "frequencyFormat_DESC"
  | "controlWarnRate_ASC"
  | "controlWarnRate_DESC"
  | "statusAsString_ASC"
  | "statusAsString_DESC";

export type TrunkedCallSourceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "sourceId_ASC"
  | "sourceId_DESC"
  | "time_ASC"
  | "time_DESC"
  | "position_ASC"
  | "position_DESC";

export type Dump1090AircraftOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "IcaoID_ASC"
  | "IcaoID_DESC";

export type Dump1090MessageType =
  | "SELECTION_CHANGE"
  | "NEW_ID"
  | "NEW_AIRCRAFT"
  | "STATUS_AIRCRAFT"
  | "CLICK"
  | "TRANSMISSION";

export type TrunkedSystemOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "type_ASC"
  | "type_DESC"
  | "recordUnknown_ASC"
  | "recordUnknown_DESC"
  | "shortName_ASC"
  | "shortName_DESC"
  | "uploadScript_ASC"
  | "uploadScript_DESC"
  | "audioArchive_ASC"
  | "audioArchive_DESC"
  | "callLog_ASC"
  | "callLog_DESC"
  | "bandplan_ASC"
  | "bandplan_DESC"
  | "bandplanBase_ASC"
  | "bandplanBase_DESC"
  | "bandplanHigh_ASC"
  | "bandplanHigh_DESC"
  | "bandplanSpacing_ASC"
  | "bandplanSpacing_DESC"
  | "bandplanOffset_ASC"
  | "bandplanOffset_DESC"
  | "talkgroupDisplayFormat_ASC"
  | "talkgroupDisplayFormat_DESC"
  | "delayCreateOutput_ASC"
  | "delayCreateOutput_DESC"
  | "hideEncrypted_ASC"
  | "hideEncrypted_DESC"
  | "hideUnknownTalkgroups_ASC"
  | "hideUnknownTalkgroups_DESC";

export type Dump1090TransmissionType =
  | "ES_IDENT_AND_CATEGORY"
  | "ES_SURFACE_POS"
  | "ES_AIRBORNE_POS"
  | "ES_AIRBORNE_VEL"
  | "SURVEILLANCE_ALT"
  | "SURVEILLANCE_ID"
  | "AIR_TO_AIR"
  | "ALL_CALL_REPLY";

export type TrunkedModulation = "QPSK" | "FSK4";

export type TrunkedCallOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "frequency_ASC"
  | "frequency_DESC"
  | "startTime_ASC"
  | "startTime_DESC"
  | "endTime_ASC"
  | "endTime_DESC"
  | "emergency_ASC"
  | "emergency_DESC"
  | "duration_ASC"
  | "duration_DESC"
  | "source_ASC"
  | "source_DESC"
  | "audioPath_ASC"
  | "audioPath_DESC"
  | "callHash_ASC"
  | "callHash_DESC"
  | "wavPath_ASC"
  | "wavPath_DESC"
  | "remotePath_ASC"
  | "remotePath_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type TrunkedSmartnetBandplan =
  | "STANDARD_800"
  | "REBAND_800"
  | "SPLINTER_800"
  | "CUSTOM_400";

export type Dump1090MessageOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "messageType_ASC"
  | "messageType_DESC"
  | "transmissionType_ASC"
  | "transmissionType_DESC"
  | "generated_ASC"
  | "generated_DESC"
  | "logged_ASC"
  | "logged_DESC"
  | "flightId_ASC"
  | "flightId_DESC"
  | "squawk_ASC"
  | "squawk_DESC"
  | "alert_ASC"
  | "alert_DESC"
  | "emergency_ASC"
  | "emergency_DESC"
  | "isOnGround_ASC"
  | "isOnGround_DESC"
  | "latitude_ASC"
  | "latitude_DESC"
  | "longitude_ASC"
  | "longitude_DESC"
  | "verticalRate_ASC"
  | "verticalRate_DESC"
  | "track_ASC"
  | "track_DESC"
  | "groupSpeed_ASC"
  | "groupSpeed_DESC"
  | "callsign_ASC"
  | "callsign_DESC"
  | "altitude_ASC"
  | "altitude_DESC";

export type TrunkedTalkgroupDisplayFormat = "ID" | "ID_TAG" | "TAG_ID";

export type TrunkedTalkgroupOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "decimal_ASC"
  | "decimal_DESC"
  | "mode_ASC"
  | "mode_DESC"
  | "alphaTag_ASC"
  | "alphaTag_DESC"
  | "description_ASC"
  | "description_DESC"
  | "tag_ASC"
  | "tag_DESC"
  | "group_ASC"
  | "group_DESC"
  | "priority_ASC"
  | "priority_DESC"
  | "hash_ASC"
  | "hash_DESC";

export type TrunkedFrequencyFormat = "EXP" | "MHZ" | "HZ";

export type TranscriptionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "languageModel_ASC"
  | "languageModel_DESC"
  | "beta_ASC"
  | "beta_DESC"
  | "body_ASC"
  | "body_DESC"
  | "duration_ASC"
  | "duration_DESC"
  | "alpha_ASC"
  | "alpha_DESC";

export type TrunkedSourceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "center_ASC"
  | "center_DESC"
  | "rate_ASC"
  | "rate_DESC"
  | "squelch_ASC"
  | "squelch_DESC"
  | "error_ASC"
  | "error_DESC"
  | "gain_ASC"
  | "gain_DESC"
  | "digitalRecorders_ASC"
  | "digitalRecorders_DESC"
  | "digitalLevels_ASC"
  | "digitalLevels_DESC"
  | "analogRecorders_ASC"
  | "analogRecorders_DESC"
  | "analogLevels_ASC"
  | "analogLevels_DESC"
  | "device_ASC"
  | "device_DESC"
  | "modulation_ASC"
  | "modulation_DESC";

export type TrunkedDefaultMode = "ANALOG" | "DIGITAL";

export interface TrunkedCallUpdateWithoutTranscriptionDataInput {
  frequency?: Maybe<Int>;
  startTime?: Maybe<DateTimeInput>;
  endTime?: Maybe<DateTimeInput>;
  emergency?: Maybe<Boolean>;
  talkgroup?: Maybe<TrunkedTalkgroupUpdateOneWithoutCallsInput>;
  system?: Maybe<TrunkedSystemUpdateOneWithoutCallsInput>;
  sources?: Maybe<TrunkedCallSourceUpdateManyInput>;
  duration?: Maybe<Float>;
  source?: Maybe<Int>;
  audioPath?: Maybe<String>;
  frequencyList?: Maybe<TrunkedCallFrequencyTimeUpdateManyInput>;
  callHash?: Maybe<String>;
  wavPath?: Maybe<String>;
  remotePath?: Maybe<String>;
}

export type Dump1090AircraftWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  IcaoID?: Maybe<String>;
}>;

export interface TrunkedTalkgroupCreateOneWithoutCallsInput {
  create?: Maybe<TrunkedTalkgroupCreateWithoutCallsInput>;
  connect?: Maybe<TrunkedTalkgroupWhereUniqueInput>;
}

export interface TranscriptionCreateWithoutWordsInput {
  id?: Maybe<ID_Input>;
  call: TrunkedCallCreateOneWithoutTranscriptionInput;
  languageModel: String;
  beta: Float;
  body: String;
  duration: Float;
  alpha: Float;
}

export interface TrunkedTalkgroupCreateWithoutCallsInput {
  id?: Maybe<ID_Input>;
  decimal: Int;
  mode?: Maybe<String>;
  alphaTag?: Maybe<String>;
  description?: Maybe<String>;
  tag?: Maybe<String>;
  group?: Maybe<String>;
  priority?: Maybe<Int>;
  system?: Maybe<TrunkedSystemCreateOneWithoutTalkgroupsInput>;
  hash: String;
}

export interface TrunkedCallSourceUpdateManyInput {
  create?: Maybe<TrunkedCallSourceCreateInput[] | TrunkedCallSourceCreateInput>;
  update?: Maybe<
    | TrunkedCallSourceUpdateWithWhereUniqueNestedInput[]
    | TrunkedCallSourceUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | TrunkedCallSourceUpsertWithWhereUniqueNestedInput[]
    | TrunkedCallSourceUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<
    TrunkedCallSourceWhereUniqueInput[] | TrunkedCallSourceWhereUniqueInput
  >;
  connect?: Maybe<
    TrunkedCallSourceWhereUniqueInput[] | TrunkedCallSourceWhereUniqueInput
  >;
  set?: Maybe<
    TrunkedCallSourceWhereUniqueInput[] | TrunkedCallSourceWhereUniqueInput
  >;
  disconnect?: Maybe<
    TrunkedCallSourceWhereUniqueInput[] | TrunkedCallSourceWhereUniqueInput
  >;
  deleteMany?: Maybe<
    TrunkedCallSourceScalarWhereInput[] | TrunkedCallSourceScalarWhereInput
  >;
  updateMany?: Maybe<
    | TrunkedCallSourceUpdateManyWithWhereNestedInput[]
    | TrunkedCallSourceUpdateManyWithWhereNestedInput
  >;
}

export interface TrunkedSystemCreateOneWithoutTalkgroupsInput {
  create?: Maybe<TrunkedSystemCreateWithoutTalkgroupsInput>;
  connect?: Maybe<TrunkedSystemWhereUniqueInput>;
}

export interface TrunkedSystemSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TrunkedSystemWhereInput>;
  AND?: Maybe<
    TrunkedSystemSubscriptionWhereInput[] | TrunkedSystemSubscriptionWhereInput
  >;
  OR?: Maybe<
    TrunkedSystemSubscriptionWhereInput[] | TrunkedSystemSubscriptionWhereInput
  >;
  NOT?: Maybe<
    TrunkedSystemSubscriptionWhereInput[] | TrunkedSystemSubscriptionWhereInput
  >;
}

export interface TrunkedSystemCreateWithoutTalkgroupsInput {
  id?: Maybe<ID_Input>;
  controlChannels?: Maybe<TrunkedSystemCreatecontrolChannelsInput>;
  channels?: Maybe<TrunkedSystemCreatechannelsInput>;
  type: TrunkedSystemType;
  alphatags?: Maybe<TrunkedSystemCreatealphatagsInput>;
  recordUnknown?: Maybe<Boolean>;
  shortName?: Maybe<String>;
  uploadScript?: Maybe<String>;
  audioArchive?: Maybe<Boolean>;
  callLog?: Maybe<Boolean>;
  bandplan?: Maybe<TrunkedSmartnetBandplan>;
  bandplanBase?: Maybe<Float>;
  bandplanHigh?: Maybe<Float>;
  bandplanSpacing?: Maybe<Float>;
  bandplanOffset?: Maybe<Float>;
  talkgroupDisplayFormat?: Maybe<TrunkedTalkgroupDisplayFormat>;
  delayCreateOutput?: Maybe<Boolean>;
  hideEncrypted?: Maybe<Boolean>;
  hideUnknownTalkgroups?: Maybe<Boolean>;
  calls?: Maybe<TrunkedCallCreateManyWithoutSystemInput>;
}

export interface TrunkedConfigSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TrunkedConfigWhereInput>;
  AND?: Maybe<
    TrunkedConfigSubscriptionWhereInput[] | TrunkedConfigSubscriptionWhereInput
  >;
  OR?: Maybe<
    TrunkedConfigSubscriptionWhereInput[] | TrunkedConfigSubscriptionWhereInput
  >;
  NOT?: Maybe<
    TrunkedConfigSubscriptionWhereInput[] | TrunkedConfigSubscriptionWhereInput
  >;
}

export interface TrunkedSystemCreatecontrolChannelsInput {
  set?: Maybe<Float[] | Float>;
}

export interface TrunkedTalkgroupWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  decimal?: Maybe<Int>;
  decimal_not?: Maybe<Int>;
  decimal_in?: Maybe<Int[] | Int>;
  decimal_not_in?: Maybe<Int[] | Int>;
  decimal_lt?: Maybe<Int>;
  decimal_lte?: Maybe<Int>;
  decimal_gt?: Maybe<Int>;
  decimal_gte?: Maybe<Int>;
  mode?: Maybe<String>;
  mode_not?: Maybe<String>;
  mode_in?: Maybe<String[] | String>;
  mode_not_in?: Maybe<String[] | String>;
  mode_lt?: Maybe<String>;
  mode_lte?: Maybe<String>;
  mode_gt?: Maybe<String>;
  mode_gte?: Maybe<String>;
  mode_contains?: Maybe<String>;
  mode_not_contains?: Maybe<String>;
  mode_starts_with?: Maybe<String>;
  mode_not_starts_with?: Maybe<String>;
  mode_ends_with?: Maybe<String>;
  mode_not_ends_with?: Maybe<String>;
  alphaTag?: Maybe<String>;
  alphaTag_not?: Maybe<String>;
  alphaTag_in?: Maybe<String[] | String>;
  alphaTag_not_in?: Maybe<String[] | String>;
  alphaTag_lt?: Maybe<String>;
  alphaTag_lte?: Maybe<String>;
  alphaTag_gt?: Maybe<String>;
  alphaTag_gte?: Maybe<String>;
  alphaTag_contains?: Maybe<String>;
  alphaTag_not_contains?: Maybe<String>;
  alphaTag_starts_with?: Maybe<String>;
  alphaTag_not_starts_with?: Maybe<String>;
  alphaTag_ends_with?: Maybe<String>;
  alphaTag_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  tag?: Maybe<String>;
  tag_not?: Maybe<String>;
  tag_in?: Maybe<String[] | String>;
  tag_not_in?: Maybe<String[] | String>;
  tag_lt?: Maybe<String>;
  tag_lte?: Maybe<String>;
  tag_gt?: Maybe<String>;
  tag_gte?: Maybe<String>;
  tag_contains?: Maybe<String>;
  tag_not_contains?: Maybe<String>;
  tag_starts_with?: Maybe<String>;
  tag_not_starts_with?: Maybe<String>;
  tag_ends_with?: Maybe<String>;
  tag_not_ends_with?: Maybe<String>;
  group?: Maybe<String>;
  group_not?: Maybe<String>;
  group_in?: Maybe<String[] | String>;
  group_not_in?: Maybe<String[] | String>;
  group_lt?: Maybe<String>;
  group_lte?: Maybe<String>;
  group_gt?: Maybe<String>;
  group_gte?: Maybe<String>;
  group_contains?: Maybe<String>;
  group_not_contains?: Maybe<String>;
  group_starts_with?: Maybe<String>;
  group_not_starts_with?: Maybe<String>;
  group_ends_with?: Maybe<String>;
  group_not_ends_with?: Maybe<String>;
  priority?: Maybe<Int>;
  priority_not?: Maybe<Int>;
  priority_in?: Maybe<Int[] | Int>;
  priority_not_in?: Maybe<Int[] | Int>;
  priority_lt?: Maybe<Int>;
  priority_lte?: Maybe<Int>;
  priority_gt?: Maybe<Int>;
  priority_gte?: Maybe<Int>;
  system?: Maybe<TrunkedSystemWhereInput>;
  calls_every?: Maybe<TrunkedCallWhereInput>;
  calls_some?: Maybe<TrunkedCallWhereInput>;
  calls_none?: Maybe<TrunkedCallWhereInput>;
  hash?: Maybe<String>;
  hash_not?: Maybe<String>;
  hash_in?: Maybe<String[] | String>;
  hash_not_in?: Maybe<String[] | String>;
  hash_lt?: Maybe<String>;
  hash_lte?: Maybe<String>;
  hash_gt?: Maybe<String>;
  hash_gte?: Maybe<String>;
  hash_contains?: Maybe<String>;
  hash_not_contains?: Maybe<String>;
  hash_starts_with?: Maybe<String>;
  hash_not_starts_with?: Maybe<String>;
  hash_ends_with?: Maybe<String>;
  hash_not_ends_with?: Maybe<String>;
  AND?: Maybe<TrunkedTalkgroupWhereInput[] | TrunkedTalkgroupWhereInput>;
  OR?: Maybe<TrunkedTalkgroupWhereInput[] | TrunkedTalkgroupWhereInput>;
  NOT?: Maybe<TrunkedTalkgroupWhereInput[] | TrunkedTalkgroupWhereInput>;
}

export interface TrunkedSystemCreatechannelsInput {
  set?: Maybe<Float[] | Float>;
}

export interface TrunkedCallFrequencyTimeSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TrunkedCallFrequencyTimeWhereInput>;
  AND?: Maybe<
    | TrunkedCallFrequencyTimeSubscriptionWhereInput[]
    | TrunkedCallFrequencyTimeSubscriptionWhereInput
  >;
  OR?: Maybe<
    | TrunkedCallFrequencyTimeSubscriptionWhereInput[]
    | TrunkedCallFrequencyTimeSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | TrunkedCallFrequencyTimeSubscriptionWhereInput[]
    | TrunkedCallFrequencyTimeSubscriptionWhereInput
  >;
}

export interface TrunkedSystemCreatealphatagsInput {
  set?: Maybe<String[] | String>;
}

export interface TrunkedCallWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  frequency?: Maybe<Int>;
  frequency_not?: Maybe<Int>;
  frequency_in?: Maybe<Int[] | Int>;
  frequency_not_in?: Maybe<Int[] | Int>;
  frequency_lt?: Maybe<Int>;
  frequency_lte?: Maybe<Int>;
  frequency_gt?: Maybe<Int>;
  frequency_gte?: Maybe<Int>;
  startTime?: Maybe<DateTimeInput>;
  startTime_not?: Maybe<DateTimeInput>;
  startTime_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startTime_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startTime_lt?: Maybe<DateTimeInput>;
  startTime_lte?: Maybe<DateTimeInput>;
  startTime_gt?: Maybe<DateTimeInput>;
  startTime_gte?: Maybe<DateTimeInput>;
  endTime?: Maybe<DateTimeInput>;
  endTime_not?: Maybe<DateTimeInput>;
  endTime_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endTime_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endTime_lt?: Maybe<DateTimeInput>;
  endTime_lte?: Maybe<DateTimeInput>;
  endTime_gt?: Maybe<DateTimeInput>;
  endTime_gte?: Maybe<DateTimeInput>;
  emergency?: Maybe<Boolean>;
  emergency_not?: Maybe<Boolean>;
  talkgroup?: Maybe<TrunkedTalkgroupWhereInput>;
  system?: Maybe<TrunkedSystemWhereInput>;
  sources_every?: Maybe<TrunkedCallSourceWhereInput>;
  sources_some?: Maybe<TrunkedCallSourceWhereInput>;
  sources_none?: Maybe<TrunkedCallSourceWhereInput>;
  duration?: Maybe<Float>;
  duration_not?: Maybe<Float>;
  duration_in?: Maybe<Float[] | Float>;
  duration_not_in?: Maybe<Float[] | Float>;
  duration_lt?: Maybe<Float>;
  duration_lte?: Maybe<Float>;
  duration_gt?: Maybe<Float>;
  duration_gte?: Maybe<Float>;
  source?: Maybe<Int>;
  source_not?: Maybe<Int>;
  source_in?: Maybe<Int[] | Int>;
  source_not_in?: Maybe<Int[] | Int>;
  source_lt?: Maybe<Int>;
  source_lte?: Maybe<Int>;
  source_gt?: Maybe<Int>;
  source_gte?: Maybe<Int>;
  audioPath?: Maybe<String>;
  audioPath_not?: Maybe<String>;
  audioPath_in?: Maybe<String[] | String>;
  audioPath_not_in?: Maybe<String[] | String>;
  audioPath_lt?: Maybe<String>;
  audioPath_lte?: Maybe<String>;
  audioPath_gt?: Maybe<String>;
  audioPath_gte?: Maybe<String>;
  audioPath_contains?: Maybe<String>;
  audioPath_not_contains?: Maybe<String>;
  audioPath_starts_with?: Maybe<String>;
  audioPath_not_starts_with?: Maybe<String>;
  audioPath_ends_with?: Maybe<String>;
  audioPath_not_ends_with?: Maybe<String>;
  frequencyList_every?: Maybe<TrunkedCallFrequencyTimeWhereInput>;
  frequencyList_some?: Maybe<TrunkedCallFrequencyTimeWhereInput>;
  frequencyList_none?: Maybe<TrunkedCallFrequencyTimeWhereInput>;
  callHash?: Maybe<String>;
  callHash_not?: Maybe<String>;
  callHash_in?: Maybe<String[] | String>;
  callHash_not_in?: Maybe<String[] | String>;
  callHash_lt?: Maybe<String>;
  callHash_lte?: Maybe<String>;
  callHash_gt?: Maybe<String>;
  callHash_gte?: Maybe<String>;
  callHash_contains?: Maybe<String>;
  callHash_not_contains?: Maybe<String>;
  callHash_starts_with?: Maybe<String>;
  callHash_not_starts_with?: Maybe<String>;
  callHash_ends_with?: Maybe<String>;
  callHash_not_ends_with?: Maybe<String>;
  wavPath?: Maybe<String>;
  wavPath_not?: Maybe<String>;
  wavPath_in?: Maybe<String[] | String>;
  wavPath_not_in?: Maybe<String[] | String>;
  wavPath_lt?: Maybe<String>;
  wavPath_lte?: Maybe<String>;
  wavPath_gt?: Maybe<String>;
  wavPath_gte?: Maybe<String>;
  wavPath_contains?: Maybe<String>;
  wavPath_not_contains?: Maybe<String>;
  wavPath_starts_with?: Maybe<String>;
  wavPath_not_starts_with?: Maybe<String>;
  wavPath_ends_with?: Maybe<String>;
  wavPath_not_ends_with?: Maybe<String>;
  transcription?: Maybe<TranscriptionWhereInput>;
  remotePath?: Maybe<String>;
  remotePath_not?: Maybe<String>;
  remotePath_in?: Maybe<String[] | String>;
  remotePath_not_in?: Maybe<String[] | String>;
  remotePath_lt?: Maybe<String>;
  remotePath_lte?: Maybe<String>;
  remotePath_gt?: Maybe<String>;
  remotePath_gte?: Maybe<String>;
  remotePath_contains?: Maybe<String>;
  remotePath_not_contains?: Maybe<String>;
  remotePath_starts_with?: Maybe<String>;
  remotePath_not_starts_with?: Maybe<String>;
  remotePath_ends_with?: Maybe<String>;
  remotePath_not_ends_with?: Maybe<String>;
  AND?: Maybe<TrunkedCallWhereInput[] | TrunkedCallWhereInput>;
  OR?: Maybe<TrunkedCallWhereInput[] | TrunkedCallWhereInput>;
  NOT?: Maybe<TrunkedCallWhereInput[] | TrunkedCallWhereInput>;
}

export interface TrunkedCallCreateManyWithoutSystemInput {
  create?: Maybe<
    TrunkedCallCreateWithoutSystemInput[] | TrunkedCallCreateWithoutSystemInput
  >;
  connect?: Maybe<TrunkedCallWhereUniqueInput[] | TrunkedCallWhereUniqueInput>;
}

export interface TrunkedCallFrequencyTimeWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  frequency?: Maybe<Int>;
  frequency_not?: Maybe<Int>;
  frequency_in?: Maybe<Int[] | Int>;
  frequency_not_in?: Maybe<Int[] | Int>;
  frequency_lt?: Maybe<Int>;
  frequency_lte?: Maybe<Int>;
  frequency_gt?: Maybe<Int>;
  frequency_gte?: Maybe<Int>;
  time?: Maybe<Int>;
  time_not?: Maybe<Int>;
  time_in?: Maybe<Int[] | Int>;
  time_not_in?: Maybe<Int[] | Int>;
  time_lt?: Maybe<Int>;
  time_lte?: Maybe<Int>;
  time_gt?: Maybe<Int>;
  time_gte?: Maybe<Int>;
  position?: Maybe<Float>;
  position_not?: Maybe<Float>;
  position_in?: Maybe<Float[] | Float>;
  position_not_in?: Maybe<Float[] | Float>;
  position_lt?: Maybe<Float>;
  position_lte?: Maybe<Float>;
  position_gt?: Maybe<Float>;
  position_gte?: Maybe<Float>;
  length?: Maybe<Int>;
  length_not?: Maybe<Int>;
  length_in?: Maybe<Int[] | Int>;
  length_not_in?: Maybe<Int[] | Int>;
  length_lt?: Maybe<Int>;
  length_lte?: Maybe<Int>;
  length_gt?: Maybe<Int>;
  length_gte?: Maybe<Int>;
  errors?: Maybe<Int>;
  errors_not?: Maybe<Int>;
  errors_in?: Maybe<Int[] | Int>;
  errors_not_in?: Maybe<Int[] | Int>;
  errors_lt?: Maybe<Int>;
  errors_lte?: Maybe<Int>;
  errors_gt?: Maybe<Int>;
  errors_gte?: Maybe<Int>;
  spikes?: Maybe<Int>;
  spikes_not?: Maybe<Int>;
  spikes_in?: Maybe<Int[] | Int>;
  spikes_not_in?: Maybe<Int[] | Int>;
  spikes_lt?: Maybe<Int>;
  spikes_lte?: Maybe<Int>;
  spikes_gt?: Maybe<Int>;
  spikes_gte?: Maybe<Int>;
  AND?: Maybe<
    TrunkedCallFrequencyTimeWhereInput[] | TrunkedCallFrequencyTimeWhereInput
  >;
  OR?: Maybe<
    TrunkedCallFrequencyTimeWhereInput[] | TrunkedCallFrequencyTimeWhereInput
  >;
  NOT?: Maybe<
    TrunkedCallFrequencyTimeWhereInput[] | TrunkedCallFrequencyTimeWhereInput
  >;
}

export interface TrunkedCallCreateWithoutSystemInput {
  id?: Maybe<ID_Input>;
  frequency: Int;
  startTime: DateTimeInput;
  endTime: DateTimeInput;
  emergency?: Maybe<Boolean>;
  talkgroup?: Maybe<TrunkedTalkgroupCreateOneWithoutCallsInput>;
  sources?: Maybe<TrunkedCallSourceCreateManyInput>;
  duration?: Maybe<Float>;
  source?: Maybe<Int>;
  audioPath?: Maybe<String>;
  frequencyList?: Maybe<TrunkedCallFrequencyTimeCreateManyInput>;
  callHash?: Maybe<String>;
  wavPath?: Maybe<String>;
  transcription?: Maybe<TranscriptionCreateOneWithoutCallInput>;
  remotePath?: Maybe<String>;
}

export interface TranscriptionWordWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  transcription?: Maybe<TranscriptionWhereInput>;
  confidence?: Maybe<Float>;
  confidence_not?: Maybe<Float>;
  confidence_in?: Maybe<Float[] | Float>;
  confidence_not_in?: Maybe<Float[] | Float>;
  confidence_lt?: Maybe<Float>;
  confidence_lte?: Maybe<Float>;
  confidence_gt?: Maybe<Float>;
  confidence_gte?: Maybe<Float>;
  end?: Maybe<Int>;
  end_not?: Maybe<Int>;
  end_in?: Maybe<Int[] | Int>;
  end_not_in?: Maybe<Int[] | Int>;
  end_lt?: Maybe<Int>;
  end_lte?: Maybe<Int>;
  end_gt?: Maybe<Int>;
  end_gte?: Maybe<Int>;
  start?: Maybe<Int>;
  start_not?: Maybe<Int>;
  start_in?: Maybe<Int[] | Int>;
  start_not_in?: Maybe<Int[] | Int>;
  start_lt?: Maybe<Int>;
  start_lte?: Maybe<Int>;
  start_gt?: Maybe<Int>;
  start_gte?: Maybe<Int>;
  AND?: Maybe<TranscriptionWordWhereInput[] | TranscriptionWordWhereInput>;
  OR?: Maybe<TranscriptionWordWhereInput[] | TranscriptionWordWhereInput>;
  NOT?: Maybe<TranscriptionWordWhereInput[] | TranscriptionWordWhereInput>;
}

export interface TrunkedCallSourceCreateManyInput {
  create?: Maybe<TrunkedCallSourceCreateInput[] | TrunkedCallSourceCreateInput>;
  connect?: Maybe<
    TrunkedCallSourceWhereUniqueInput[] | TrunkedCallSourceWhereUniqueInput
  >;
}

export interface TranscriptionWordSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TranscriptionWordWhereInput>;
  AND?: Maybe<
    | TranscriptionWordSubscriptionWhereInput[]
    | TranscriptionWordSubscriptionWhereInput
  >;
  OR?: Maybe<
    | TranscriptionWordSubscriptionWhereInput[]
    | TranscriptionWordSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | TranscriptionWordSubscriptionWhereInput[]
    | TranscriptionWordSubscriptionWhereInput
  >;
}

export interface TrunkedCallSourceCreateInput {
  id?: Maybe<ID_Input>;
  sourceId?: Maybe<Int>;
  time?: Maybe<DateTimeInput>;
  position?: Maybe<Float>;
}

export interface Dump1090MessageSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<Dump1090MessageWhereInput>;
  AND?: Maybe<
    | Dump1090MessageSubscriptionWhereInput[]
    | Dump1090MessageSubscriptionWhereInput
  >;
  OR?: Maybe<
    | Dump1090MessageSubscriptionWhereInput[]
    | Dump1090MessageSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | Dump1090MessageSubscriptionWhereInput[]
    | Dump1090MessageSubscriptionWhereInput
  >;
}

export interface TrunkedCallFrequencyTimeCreateManyInput {
  create?: Maybe<
    TrunkedCallFrequencyTimeCreateInput[] | TrunkedCallFrequencyTimeCreateInput
  >;
  connect?: Maybe<
    | TrunkedCallFrequencyTimeWhereUniqueInput[]
    | TrunkedCallFrequencyTimeWhereUniqueInput
  >;
}

export interface Dump1090AircraftSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<Dump1090AircraftWhereInput>;
  AND?: Maybe<
    | Dump1090AircraftSubscriptionWhereInput[]
    | Dump1090AircraftSubscriptionWhereInput
  >;
  OR?: Maybe<
    | Dump1090AircraftSubscriptionWhereInput[]
    | Dump1090AircraftSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | Dump1090AircraftSubscriptionWhereInput[]
    | Dump1090AircraftSubscriptionWhereInput
  >;
}

export interface TrunkedCallFrequencyTimeCreateInput {
  id?: Maybe<ID_Input>;
  frequency: Int;
  time: Int;
  position: Float;
  length: Int;
  errors: Int;
  spikes: Int;
}

export interface TrunkedTalkgroupUpdateInput {
  decimal?: Maybe<Int>;
  mode?: Maybe<String>;
  alphaTag?: Maybe<String>;
  description?: Maybe<String>;
  tag?: Maybe<String>;
  group?: Maybe<String>;
  priority?: Maybe<Int>;
  system?: Maybe<TrunkedSystemUpdateOneWithoutTalkgroupsInput>;
  calls?: Maybe<TrunkedCallUpdateManyWithoutTalkgroupInput>;
  hash?: Maybe<String>;
}

export interface TranscriptionCreateOneWithoutCallInput {
  create?: Maybe<TranscriptionCreateWithoutCallInput>;
  connect?: Maybe<TranscriptionWhereUniqueInput>;
}

export interface TrunkedSystemUpdateManyMutationInput {
  controlChannels?: Maybe<TrunkedSystemUpdatecontrolChannelsInput>;
  channels?: Maybe<TrunkedSystemUpdatechannelsInput>;
  type?: Maybe<TrunkedSystemType>;
  alphatags?: Maybe<TrunkedSystemUpdatealphatagsInput>;
  recordUnknown?: Maybe<Boolean>;
  shortName?: Maybe<String>;
  uploadScript?: Maybe<String>;
  audioArchive?: Maybe<Boolean>;
  callLog?: Maybe<Boolean>;
  bandplan?: Maybe<TrunkedSmartnetBandplan>;
  bandplanBase?: Maybe<Float>;
  bandplanHigh?: Maybe<Float>;
  bandplanSpacing?: Maybe<Float>;
  bandplanOffset?: Maybe<Float>;
  talkgroupDisplayFormat?: Maybe<TrunkedTalkgroupDisplayFormat>;
  delayCreateOutput?: Maybe<Boolean>;
  hideEncrypted?: Maybe<Boolean>;
  hideUnknownTalkgroups?: Maybe<Boolean>;
}

export interface TranscriptionCreateWithoutCallInput {
  id?: Maybe<ID_Input>;
  languageModel: String;
  beta: Float;
  body: String;
  words?: Maybe<TranscriptionWordCreateManyWithoutTranscriptionInput>;
  duration: Float;
  alpha: Float;
}

export interface TrunkedSourceUpdateManyMutationInput {
  center?: Maybe<Float>;
  rate?: Maybe<Float>;
  squelch?: Maybe<Float>;
  error?: Maybe<Float>;
  gain?: Maybe<Float>;
  digitalRecorders?: Maybe<Float>;
  digitalLevels?: Maybe<Float>;
  analogRecorders?: Maybe<Float>;
  analogLevels?: Maybe<Float>;
  device?: Maybe<String>;
  modulation?: Maybe<TrunkedModulation>;
}

export interface TranscriptionWordCreateManyWithoutTranscriptionInput {
  create?: Maybe<
    | TranscriptionWordCreateWithoutTranscriptionInput[]
    | TranscriptionWordCreateWithoutTranscriptionInput
  >;
  connect?: Maybe<
    TranscriptionWordWhereUniqueInput[] | TranscriptionWordWhereUniqueInput
  >;
}

export interface TrunkedSourceUpdateInput {
  center?: Maybe<Float>;
  rate?: Maybe<Float>;
  squelch?: Maybe<Float>;
  error?: Maybe<Float>;
  gain?: Maybe<Float>;
  digitalRecorders?: Maybe<Float>;
  digitalLevels?: Maybe<Float>;
  analogRecorders?: Maybe<Float>;
  analogLevels?: Maybe<Float>;
  device?: Maybe<String>;
  modulation?: Maybe<TrunkedModulation>;
}

export interface TranscriptionWordCreateWithoutTranscriptionInput {
  id?: Maybe<ID_Input>;
  text: String;
  confidence: Float;
  end: Int;
  start: Int;
}

export interface TrunkedSystemUpdateManyDataInput {
  controlChannels?: Maybe<TrunkedSystemUpdatecontrolChannelsInput>;
  channels?: Maybe<TrunkedSystemUpdatechannelsInput>;
  type?: Maybe<TrunkedSystemType>;
  alphatags?: Maybe<TrunkedSystemUpdatealphatagsInput>;
  recordUnknown?: Maybe<Boolean>;
  shortName?: Maybe<String>;
  uploadScript?: Maybe<String>;
  audioArchive?: Maybe<Boolean>;
  callLog?: Maybe<Boolean>;
  bandplan?: Maybe<TrunkedSmartnetBandplan>;
  bandplanBase?: Maybe<Float>;
  bandplanHigh?: Maybe<Float>;
  bandplanSpacing?: Maybe<Float>;
  bandplanOffset?: Maybe<Float>;
  talkgroupDisplayFormat?: Maybe<TrunkedTalkgroupDisplayFormat>;
  delayCreateOutput?: Maybe<Boolean>;
  hideEncrypted?: Maybe<Boolean>;
  hideUnknownTalkgroups?: Maybe<Boolean>;
}

export interface TrunkedSystemCreateOneWithoutCallsInput {
  create?: Maybe<TrunkedSystemCreateWithoutCallsInput>;
  connect?: Maybe<TrunkedSystemWhereUniqueInput>;
}

export interface TrunkedSystemUpdateManyWithWhereNestedInput {
  where: TrunkedSystemScalarWhereInput;
  data: TrunkedSystemUpdateManyDataInput;
}

export interface TrunkedSystemCreateWithoutCallsInput {
  id?: Maybe<ID_Input>;
  controlChannels?: Maybe<TrunkedSystemCreatecontrolChannelsInput>;
  channels?: Maybe<TrunkedSystemCreatechannelsInput>;
  type: TrunkedSystemType;
  alphatags?: Maybe<TrunkedSystemCreatealphatagsInput>;
  talkgroups?: Maybe<TrunkedTalkgroupCreateManyWithoutSystemInput>;
  recordUnknown?: Maybe<Boolean>;
  shortName?: Maybe<String>;
  uploadScript?: Maybe<String>;
  audioArchive?: Maybe<Boolean>;
  callLog?: Maybe<Boolean>;
  bandplan?: Maybe<TrunkedSmartnetBandplan>;
  bandplanBase?: Maybe<Float>;
  bandplanHigh?: Maybe<Float>;
  bandplanSpacing?: Maybe<Float>;
  bandplanOffset?: Maybe<Float>;
  talkgroupDisplayFormat?: Maybe<TrunkedTalkgroupDisplayFormat>;
  delayCreateOutput?: Maybe<Boolean>;
  hideEncrypted?: Maybe<Boolean>;
  hideUnknownTalkgroups?: Maybe<Boolean>;
}

export interface TrunkedSystemUpsertWithWhereUniqueNestedInput {
  where: TrunkedSystemWhereUniqueInput;
  update: TrunkedSystemUpdateDataInput;
  create: TrunkedSystemCreateInput;
}

export interface TrunkedTalkgroupCreateManyWithoutSystemInput {
  create?: Maybe<
    | TrunkedTalkgroupCreateWithoutSystemInput[]
    | TrunkedTalkgroupCreateWithoutSystemInput
  >;
  connect?: Maybe<
    TrunkedTalkgroupWhereUniqueInput[] | TrunkedTalkgroupWhereUniqueInput
  >;
}

export interface TrunkedSystemUpdateDataInput {
  controlChannels?: Maybe<TrunkedSystemUpdatecontrolChannelsInput>;
  channels?: Maybe<TrunkedSystemUpdatechannelsInput>;
  type?: Maybe<TrunkedSystemType>;
  alphatags?: Maybe<TrunkedSystemUpdatealphatagsInput>;
  talkgroups?: Maybe<TrunkedTalkgroupUpdateManyWithoutSystemInput>;
  recordUnknown?: Maybe<Boolean>;
  shortName?: Maybe<String>;
  uploadScript?: Maybe<String>;
  audioArchive?: Maybe<Boolean>;
  callLog?: Maybe<Boolean>;
  bandplan?: Maybe<TrunkedSmartnetBandplan>;
  bandplanBase?: Maybe<Float>;
  bandplanHigh?: Maybe<Float>;
  bandplanSpacing?: Maybe<Float>;
  bandplanOffset?: Maybe<Float>;
  talkgroupDisplayFormat?: Maybe<TrunkedTalkgroupDisplayFormat>;
  delayCreateOutput?: Maybe<Boolean>;
  hideEncrypted?: Maybe<Boolean>;
  hideUnknownTalkgroups?: Maybe<Boolean>;
  calls?: Maybe<TrunkedCallUpdateManyWithoutSystemInput>;
}

export interface TrunkedTalkgroupCreateWithoutSystemInput {
  id?: Maybe<ID_Input>;
  decimal: Int;
  mode?: Maybe<String>;
  alphaTag?: Maybe<String>;
  description?: Maybe<String>;
  tag?: Maybe<String>;
  group?: Maybe<String>;
  priority?: Maybe<Int>;
  calls?: Maybe<TrunkedCallCreateManyWithoutTalkgroupInput>;
  hash: String;
}

export interface TrunkedSystemUpdateManyInput {
  create?: Maybe<TrunkedSystemCreateInput[] | TrunkedSystemCreateInput>;
  update?: Maybe<
    | TrunkedSystemUpdateWithWhereUniqueNestedInput[]
    | TrunkedSystemUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | TrunkedSystemUpsertWithWhereUniqueNestedInput[]
    | TrunkedSystemUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<
    TrunkedSystemWhereUniqueInput[] | TrunkedSystemWhereUniqueInput
  >;
  connect?: Maybe<
    TrunkedSystemWhereUniqueInput[] | TrunkedSystemWhereUniqueInput
  >;
  set?: Maybe<TrunkedSystemWhereUniqueInput[] | TrunkedSystemWhereUniqueInput>;
  disconnect?: Maybe<
    TrunkedSystemWhereUniqueInput[] | TrunkedSystemWhereUniqueInput
  >;
  deleteMany?: Maybe<
    TrunkedSystemScalarWhereInput[] | TrunkedSystemScalarWhereInput
  >;
  updateMany?: Maybe<
    | TrunkedSystemUpdateManyWithWhereNestedInput[]
    | TrunkedSystemUpdateManyWithWhereNestedInput
  >;
}

export interface TrunkedCallCreateManyWithoutTalkgroupInput {
  create?: Maybe<
    | TrunkedCallCreateWithoutTalkgroupInput[]
    | TrunkedCallCreateWithoutTalkgroupInput
  >;
  connect?: Maybe<TrunkedCallWhereUniqueInput[] | TrunkedCallWhereUniqueInput>;
}

export interface TrunkedSourceUpdateManyDataInput {
  center?: Maybe<Float>;
  rate?: Maybe<Float>;
  squelch?: Maybe<Float>;
  error?: Maybe<Float>;
  gain?: Maybe<Float>;
  digitalRecorders?: Maybe<Float>;
  digitalLevels?: Maybe<Float>;
  analogRecorders?: Maybe<Float>;
  analogLevels?: Maybe<Float>;
  device?: Maybe<String>;
  modulation?: Maybe<TrunkedModulation>;
}

export interface TrunkedCallCreateWithoutTalkgroupInput {
  id?: Maybe<ID_Input>;
  frequency: Int;
  startTime: DateTimeInput;
  endTime: DateTimeInput;
  emergency?: Maybe<Boolean>;
  system?: Maybe<TrunkedSystemCreateOneWithoutCallsInput>;
  sources?: Maybe<TrunkedCallSourceCreateManyInput>;
  duration?: Maybe<Float>;
  source?: Maybe<Int>;
  audioPath?: Maybe<String>;
  frequencyList?: Maybe<TrunkedCallFrequencyTimeCreateManyInput>;
  callHash?: Maybe<String>;
  wavPath?: Maybe<String>;
  transcription?: Maybe<TranscriptionCreateOneWithoutCallInput>;
  remotePath?: Maybe<String>;
}

export interface TrunkedSourceScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  center?: Maybe<Float>;
  center_not?: Maybe<Float>;
  center_in?: Maybe<Float[] | Float>;
  center_not_in?: Maybe<Float[] | Float>;
  center_lt?: Maybe<Float>;
  center_lte?: Maybe<Float>;
  center_gt?: Maybe<Float>;
  center_gte?: Maybe<Float>;
  rate?: Maybe<Float>;
  rate_not?: Maybe<Float>;
  rate_in?: Maybe<Float[] | Float>;
  rate_not_in?: Maybe<Float[] | Float>;
  rate_lt?: Maybe<Float>;
  rate_lte?: Maybe<Float>;
  rate_gt?: Maybe<Float>;
  rate_gte?: Maybe<Float>;
  squelch?: Maybe<Float>;
  squelch_not?: Maybe<Float>;
  squelch_in?: Maybe<Float[] | Float>;
  squelch_not_in?: Maybe<Float[] | Float>;
  squelch_lt?: Maybe<Float>;
  squelch_lte?: Maybe<Float>;
  squelch_gt?: Maybe<Float>;
  squelch_gte?: Maybe<Float>;
  error?: Maybe<Float>;
  error_not?: Maybe<Float>;
  error_in?: Maybe<Float[] | Float>;
  error_not_in?: Maybe<Float[] | Float>;
  error_lt?: Maybe<Float>;
  error_lte?: Maybe<Float>;
  error_gt?: Maybe<Float>;
  error_gte?: Maybe<Float>;
  gain?: Maybe<Float>;
  gain_not?: Maybe<Float>;
  gain_in?: Maybe<Float[] | Float>;
  gain_not_in?: Maybe<Float[] | Float>;
  gain_lt?: Maybe<Float>;
  gain_lte?: Maybe<Float>;
  gain_gt?: Maybe<Float>;
  gain_gte?: Maybe<Float>;
  digitalRecorders?: Maybe<Float>;
  digitalRecorders_not?: Maybe<Float>;
  digitalRecorders_in?: Maybe<Float[] | Float>;
  digitalRecorders_not_in?: Maybe<Float[] | Float>;
  digitalRecorders_lt?: Maybe<Float>;
  digitalRecorders_lte?: Maybe<Float>;
  digitalRecorders_gt?: Maybe<Float>;
  digitalRecorders_gte?: Maybe<Float>;
  digitalLevels?: Maybe<Float>;
  digitalLevels_not?: Maybe<Float>;
  digitalLevels_in?: Maybe<Float[] | Float>;
  digitalLevels_not_in?: Maybe<Float[] | Float>;
  digitalLevels_lt?: Maybe<Float>;
  digitalLevels_lte?: Maybe<Float>;
  digitalLevels_gt?: Maybe<Float>;
  digitalLevels_gte?: Maybe<Float>;
  analogRecorders?: Maybe<Float>;
  analogRecorders_not?: Maybe<Float>;
  analogRecorders_in?: Maybe<Float[] | Float>;
  analogRecorders_not_in?: Maybe<Float[] | Float>;
  analogRecorders_lt?: Maybe<Float>;
  analogRecorders_lte?: Maybe<Float>;
  analogRecorders_gt?: Maybe<Float>;
  analogRecorders_gte?: Maybe<Float>;
  analogLevels?: Maybe<Float>;
  analogLevels_not?: Maybe<Float>;
  analogLevels_in?: Maybe<Float[] | Float>;
  analogLevels_not_in?: Maybe<Float[] | Float>;
  analogLevels_lt?: Maybe<Float>;
  analogLevels_lte?: Maybe<Float>;
  analogLevels_gt?: Maybe<Float>;
  analogLevels_gte?: Maybe<Float>;
  device?: Maybe<String>;
  device_not?: Maybe<String>;
  device_in?: Maybe<String[] | String>;
  device_not_in?: Maybe<String[] | String>;
  device_lt?: Maybe<String>;
  device_lte?: Maybe<String>;
  device_gt?: Maybe<String>;
  device_gte?: Maybe<String>;
  device_contains?: Maybe<String>;
  device_not_contains?: Maybe<String>;
  device_starts_with?: Maybe<String>;
  device_not_starts_with?: Maybe<String>;
  device_ends_with?: Maybe<String>;
  device_not_ends_with?: Maybe<String>;
  modulation?: Maybe<TrunkedModulation>;
  modulation_not?: Maybe<TrunkedModulation>;
  modulation_in?: Maybe<TrunkedModulation[] | TrunkedModulation>;
  modulation_not_in?: Maybe<TrunkedModulation[] | TrunkedModulation>;
  AND?: Maybe<TrunkedSourceScalarWhereInput[] | TrunkedSourceScalarWhereInput>;
  OR?: Maybe<TrunkedSourceScalarWhereInput[] | TrunkedSourceScalarWhereInput>;
  NOT?: Maybe<TrunkedSourceScalarWhereInput[] | TrunkedSourceScalarWhereInput>;
}

export interface TranscriptionUpdateInput {
  call?: Maybe<TrunkedCallUpdateOneRequiredWithoutTranscriptionInput>;
  languageModel?: Maybe<String>;
  beta?: Maybe<Float>;
  body?: Maybe<String>;
  words?: Maybe<TranscriptionWordUpdateManyWithoutTranscriptionInput>;
  duration?: Maybe<Float>;
  alpha?: Maybe<Float>;
}

export interface TrunkedSourceUpsertWithWhereUniqueNestedInput {
  where: TrunkedSourceWhereUniqueInput;
  update: TrunkedSourceUpdateDataInput;
  create: TrunkedSourceCreateInput;
}

export interface TrunkedCallUpdateOneRequiredWithoutTranscriptionInput {
  create?: Maybe<TrunkedCallCreateWithoutTranscriptionInput>;
  update?: Maybe<TrunkedCallUpdateWithoutTranscriptionDataInput>;
  upsert?: Maybe<TrunkedCallUpsertWithoutTranscriptionInput>;
  connect?: Maybe<TrunkedCallWhereUniqueInput>;
}

export interface TrunkedSourceUpdateDataInput {
  center?: Maybe<Float>;
  rate?: Maybe<Float>;
  squelch?: Maybe<Float>;
  error?: Maybe<Float>;
  gain?: Maybe<Float>;
  digitalRecorders?: Maybe<Float>;
  digitalLevels?: Maybe<Float>;
  analogRecorders?: Maybe<Float>;
  analogLevels?: Maybe<Float>;
  device?: Maybe<String>;
  modulation?: Maybe<TrunkedModulation>;
}

export interface TranscriptionWordUpdateInput {
  text?: Maybe<String>;
  transcription?: Maybe<TranscriptionUpdateOneRequiredWithoutWordsInput>;
  confidence?: Maybe<Float>;
  end?: Maybe<Int>;
  start?: Maybe<Int>;
}

export interface TrunkedSourceUpdateManyInput {
  create?: Maybe<TrunkedSourceCreateInput[] | TrunkedSourceCreateInput>;
  update?: Maybe<
    | TrunkedSourceUpdateWithWhereUniqueNestedInput[]
    | TrunkedSourceUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | TrunkedSourceUpsertWithWhereUniqueNestedInput[]
    | TrunkedSourceUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<
    TrunkedSourceWhereUniqueInput[] | TrunkedSourceWhereUniqueInput
  >;
  connect?: Maybe<
    TrunkedSourceWhereUniqueInput[] | TrunkedSourceWhereUniqueInput
  >;
  set?: Maybe<TrunkedSourceWhereUniqueInput[] | TrunkedSourceWhereUniqueInput>;
  disconnect?: Maybe<
    TrunkedSourceWhereUniqueInput[] | TrunkedSourceWhereUniqueInput
  >;
  deleteMany?: Maybe<
    TrunkedSourceScalarWhereInput[] | TrunkedSourceScalarWhereInput
  >;
  updateMany?: Maybe<
    | TrunkedSourceUpdateManyWithWhereNestedInput[]
    | TrunkedSourceUpdateManyWithWhereNestedInput
  >;
}

export interface TrunkedTalkgroupUpdateOneWithoutCallsInput {
  create?: Maybe<TrunkedTalkgroupCreateWithoutCallsInput>;
  update?: Maybe<TrunkedTalkgroupUpdateWithoutCallsDataInput>;
  upsert?: Maybe<TrunkedTalkgroupUpsertWithoutCallsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<TrunkedTalkgroupWhereUniqueInput>;
}

export interface TrunkedSystemCreateInput {
  id?: Maybe<ID_Input>;
  controlChannels?: Maybe<TrunkedSystemCreatecontrolChannelsInput>;
  channels?: Maybe<TrunkedSystemCreatechannelsInput>;
  type: TrunkedSystemType;
  alphatags?: Maybe<TrunkedSystemCreatealphatagsInput>;
  talkgroups?: Maybe<TrunkedTalkgroupCreateManyWithoutSystemInput>;
  recordUnknown?: Maybe<Boolean>;
  shortName?: Maybe<String>;
  uploadScript?: Maybe<String>;
  audioArchive?: Maybe<Boolean>;
  callLog?: Maybe<Boolean>;
  bandplan?: Maybe<TrunkedSmartnetBandplan>;
  bandplanBase?: Maybe<Float>;
  bandplanHigh?: Maybe<Float>;
  bandplanSpacing?: Maybe<Float>;
  bandplanOffset?: Maybe<Float>;
  talkgroupDisplayFormat?: Maybe<TrunkedTalkgroupDisplayFormat>;
  delayCreateOutput?: Maybe<Boolean>;
  hideEncrypted?: Maybe<Boolean>;
  hideUnknownTalkgroups?: Maybe<Boolean>;
  calls?: Maybe<TrunkedCallCreateManyWithoutSystemInput>;
}

export interface TrunkedTalkgroupUpdateWithoutCallsDataInput {
  decimal?: Maybe<Int>;
  mode?: Maybe<String>;
  alphaTag?: Maybe<String>;
  description?: Maybe<String>;
  tag?: Maybe<String>;
  group?: Maybe<String>;
  priority?: Maybe<Int>;
  system?: Maybe<TrunkedSystemUpdateOneWithoutTalkgroupsInput>;
  hash?: Maybe<String>;
}

export interface TrunkedConfigWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  sources_every?: Maybe<TrunkedSourceWhereInput>;
  sources_some?: Maybe<TrunkedSourceWhereInput>;
  sources_none?: Maybe<TrunkedSourceWhereInput>;
  systems_every?: Maybe<TrunkedSystemWhereInput>;
  systems_some?: Maybe<TrunkedSystemWhereInput>;
  systems_none?: Maybe<TrunkedSystemWhereInput>;
  defaultMode?: Maybe<TrunkedDefaultMode>;
  defaultMode_not?: Maybe<TrunkedDefaultMode>;
  defaultMode_in?: Maybe<TrunkedDefaultMode[] | TrunkedDefaultMode>;
  defaultMode_not_in?: Maybe<TrunkedDefaultMode[] | TrunkedDefaultMode>;
  captureDir?: Maybe<String>;
  captureDir_not?: Maybe<String>;
  captureDir_in?: Maybe<String[] | String>;
  captureDir_not_in?: Maybe<String[] | String>;
  captureDir_lt?: Maybe<String>;
  captureDir_lte?: Maybe<String>;
  captureDir_gt?: Maybe<String>;
  captureDir_gte?: Maybe<String>;
  captureDir_contains?: Maybe<String>;
  captureDir_not_contains?: Maybe<String>;
  captureDir_starts_with?: Maybe<String>;
  captureDir_not_starts_with?: Maybe<String>;
  captureDir_ends_with?: Maybe<String>;
  captureDir_not_ends_with?: Maybe<String>;
  callTimeout?: Maybe<Int>;
  callTimeout_not?: Maybe<Int>;
  callTimeout_in?: Maybe<Int[] | Int>;
  callTimeout_not_in?: Maybe<Int[] | Int>;
  callTimeout_lt?: Maybe<Int>;
  callTimeout_lte?: Maybe<Int>;
  callTimeout_gt?: Maybe<Int>;
  callTimeout_gte?: Maybe<Int>;
  logFile?: Maybe<Boolean>;
  logFile_not?: Maybe<Boolean>;
  frequencyFormat?: Maybe<TrunkedFrequencyFormat>;
  frequencyFormat_not?: Maybe<TrunkedFrequencyFormat>;
  frequencyFormat_in?: Maybe<TrunkedFrequencyFormat[] | TrunkedFrequencyFormat>;
  frequencyFormat_not_in?: Maybe<
    TrunkedFrequencyFormat[] | TrunkedFrequencyFormat
  >;
  controlWarnRate?: Maybe<Int>;
  controlWarnRate_not?: Maybe<Int>;
  controlWarnRate_in?: Maybe<Int[] | Int>;
  controlWarnRate_not_in?: Maybe<Int[] | Int>;
  controlWarnRate_lt?: Maybe<Int>;
  controlWarnRate_lte?: Maybe<Int>;
  controlWarnRate_gt?: Maybe<Int>;
  controlWarnRate_gte?: Maybe<Int>;
  statusAsString?: Maybe<Boolean>;
  statusAsString_not?: Maybe<Boolean>;
  AND?: Maybe<TrunkedConfigWhereInput[] | TrunkedConfigWhereInput>;
  OR?: Maybe<TrunkedConfigWhereInput[] | TrunkedConfigWhereInput>;
  NOT?: Maybe<TrunkedConfigWhereInput[] | TrunkedConfigWhereInput>;
}

export interface TrunkedSystemUpdateOneWithoutTalkgroupsInput {
  create?: Maybe<TrunkedSystemCreateWithoutTalkgroupsInput>;
  update?: Maybe<TrunkedSystemUpdateWithoutTalkgroupsDataInput>;
  upsert?: Maybe<TrunkedSystemUpsertWithoutTalkgroupsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<TrunkedSystemWhereUniqueInput>;
}

export interface TrunkedSourceCreateInput {
  id?: Maybe<ID_Input>;
  center: Float;
  rate: Float;
  squelch?: Maybe<Float>;
  error?: Maybe<Float>;
  gain?: Maybe<Float>;
  digitalRecorders?: Maybe<Float>;
  digitalLevels?: Maybe<Float>;
  analogRecorders?: Maybe<Float>;
  analogLevels?: Maybe<Float>;
  device: String;
  modulation: TrunkedModulation;
}

export interface TrunkedSystemUpdateWithoutTalkgroupsDataInput {
  controlChannels?: Maybe<TrunkedSystemUpdatecontrolChannelsInput>;
  channels?: Maybe<TrunkedSystemUpdatechannelsInput>;
  type?: Maybe<TrunkedSystemType>;
  alphatags?: Maybe<TrunkedSystemUpdatealphatagsInput>;
  recordUnknown?: Maybe<Boolean>;
  shortName?: Maybe<String>;
  uploadScript?: Maybe<String>;
  audioArchive?: Maybe<Boolean>;
  callLog?: Maybe<Boolean>;
  bandplan?: Maybe<TrunkedSmartnetBandplan>;
  bandplanBase?: Maybe<Float>;
  bandplanHigh?: Maybe<Float>;
  bandplanSpacing?: Maybe<Float>;
  bandplanOffset?: Maybe<Float>;
  talkgroupDisplayFormat?: Maybe<TrunkedTalkgroupDisplayFormat>;
  delayCreateOutput?: Maybe<Boolean>;
  hideEncrypted?: Maybe<Boolean>;
  hideUnknownTalkgroups?: Maybe<Boolean>;
  calls?: Maybe<TrunkedCallUpdateManyWithoutSystemInput>;
}

export interface TrunkedConfigCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  sources?: Maybe<TrunkedSourceCreateManyInput>;
  systems?: Maybe<TrunkedSystemCreateManyInput>;
  defaultMode?: Maybe<TrunkedDefaultMode>;
  captureDir: String;
  callTimeout?: Maybe<Int>;
  logFile?: Maybe<Boolean>;
  frequencyFormat?: Maybe<TrunkedFrequencyFormat>;
  controlWarnRate?: Maybe<Int>;
  statusAsString?: Maybe<Boolean>;
}

export interface TrunkedSystemUpdatecontrolChannelsInput {
  set?: Maybe<Float[] | Float>;
}

export interface TrunkedCallSourceUpdateManyMutationInput {
  sourceId?: Maybe<Int>;
  time?: Maybe<DateTimeInput>;
  position?: Maybe<Float>;
}

export interface TrunkedSystemUpdatechannelsInput {
  set?: Maybe<Float[] | Float>;
}

export interface TrunkedCallFrequencyTimeUpdateManyMutationInput {
  frequency?: Maybe<Int>;
  time?: Maybe<Int>;
  position?: Maybe<Float>;
  length?: Maybe<Int>;
  errors?: Maybe<Int>;
  spikes?: Maybe<Int>;
}

export interface TrunkedSystemUpdatealphatagsInput {
  set?: Maybe<String[] | String>;
}

export interface TrunkedCallFrequencyTimeUpdateInput {
  frequency?: Maybe<Int>;
  time?: Maybe<Int>;
  position?: Maybe<Float>;
  length?: Maybe<Int>;
  errors?: Maybe<Int>;
  spikes?: Maybe<Int>;
}

export interface TrunkedCallUpdateManyWithoutSystemInput {
  create?: Maybe<
    TrunkedCallCreateWithoutSystemInput[] | TrunkedCallCreateWithoutSystemInput
  >;
  delete?: Maybe<TrunkedCallWhereUniqueInput[] | TrunkedCallWhereUniqueInput>;
  connect?: Maybe<TrunkedCallWhereUniqueInput[] | TrunkedCallWhereUniqueInput>;
  set?: Maybe<TrunkedCallWhereUniqueInput[] | TrunkedCallWhereUniqueInput>;
  disconnect?: Maybe<
    TrunkedCallWhereUniqueInput[] | TrunkedCallWhereUniqueInput
  >;
  update?: Maybe<
    | TrunkedCallUpdateWithWhereUniqueWithoutSystemInput[]
    | TrunkedCallUpdateWithWhereUniqueWithoutSystemInput
  >;
  upsert?: Maybe<
    | TrunkedCallUpsertWithWhereUniqueWithoutSystemInput[]
    | TrunkedCallUpsertWithWhereUniqueWithoutSystemInput
  >;
  deleteMany?: Maybe<
    TrunkedCallScalarWhereInput[] | TrunkedCallScalarWhereInput
  >;
  updateMany?: Maybe<
    | TrunkedCallUpdateManyWithWhereNestedInput[]
    | TrunkedCallUpdateManyWithWhereNestedInput
  >;
}

export interface TrunkedCallUpdateInput {
  frequency?: Maybe<Int>;
  startTime?: Maybe<DateTimeInput>;
  endTime?: Maybe<DateTimeInput>;
  emergency?: Maybe<Boolean>;
  talkgroup?: Maybe<TrunkedTalkgroupUpdateOneWithoutCallsInput>;
  system?: Maybe<TrunkedSystemUpdateOneWithoutCallsInput>;
  sources?: Maybe<TrunkedCallSourceUpdateManyInput>;
  duration?: Maybe<Float>;
  source?: Maybe<Int>;
  audioPath?: Maybe<String>;
  frequencyList?: Maybe<TrunkedCallFrequencyTimeUpdateManyInput>;
  callHash?: Maybe<String>;
  wavPath?: Maybe<String>;
  transcription?: Maybe<TranscriptionUpdateOneWithoutCallInput>;
  remotePath?: Maybe<String>;
}

export interface TrunkedCallUpdateWithWhereUniqueWithoutSystemInput {
  where: TrunkedCallWhereUniqueInput;
  data: TrunkedCallUpdateWithoutSystemDataInput;
}

export interface TrunkedCallCreateInput {
  id?: Maybe<ID_Input>;
  frequency: Int;
  startTime: DateTimeInput;
  endTime: DateTimeInput;
  emergency?: Maybe<Boolean>;
  talkgroup?: Maybe<TrunkedTalkgroupCreateOneWithoutCallsInput>;
  system?: Maybe<TrunkedSystemCreateOneWithoutCallsInput>;
  sources?: Maybe<TrunkedCallSourceCreateManyInput>;
  duration?: Maybe<Float>;
  source?: Maybe<Int>;
  audioPath?: Maybe<String>;
  frequencyList?: Maybe<TrunkedCallFrequencyTimeCreateManyInput>;
  callHash?: Maybe<String>;
  wavPath?: Maybe<String>;
  transcription?: Maybe<TranscriptionCreateOneWithoutCallInput>;
  remotePath?: Maybe<String>;
}

export interface TrunkedCallUpdateWithoutSystemDataInput {
  frequency?: Maybe<Int>;
  startTime?: Maybe<DateTimeInput>;
  endTime?: Maybe<DateTimeInput>;
  emergency?: Maybe<Boolean>;
  talkgroup?: Maybe<TrunkedTalkgroupUpdateOneWithoutCallsInput>;
  sources?: Maybe<TrunkedCallSourceUpdateManyInput>;
  duration?: Maybe<Float>;
  source?: Maybe<Int>;
  audioPath?: Maybe<String>;
  frequencyList?: Maybe<TrunkedCallFrequencyTimeUpdateManyInput>;
  callHash?: Maybe<String>;
  wavPath?: Maybe<String>;
  transcription?: Maybe<TranscriptionUpdateOneWithoutCallInput>;
  remotePath?: Maybe<String>;
}

export interface TranscriptionUpsertWithoutWordsInput {
  update: TranscriptionUpdateWithoutWordsDataInput;
  create: TranscriptionCreateWithoutWordsInput;
}

export type TranscriptionWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface Dump1090AircraftCreateInput {
  id?: Maybe<ID_Input>;
  IcaoID?: Maybe<String>;
}

export interface TrunkedCallSourceUpdateWithWhereUniqueNestedInput {
  where: TrunkedCallSourceWhereUniqueInput;
  data: TrunkedCallSourceUpdateDataInput;
}

export interface Dump1090AircraftUpdateManyMutationInput {
  IcaoID?: Maybe<String>;
}

export interface TrunkedCallSourceUpdateDataInput {
  sourceId?: Maybe<Int>;
  time?: Maybe<DateTimeInput>;
  position?: Maybe<Float>;
}

export interface TranscriptionUpdateOneRequiredWithoutWordsInput {
  create?: Maybe<TranscriptionCreateWithoutWordsInput>;
  update?: Maybe<TranscriptionUpdateWithoutWordsDataInput>;
  upsert?: Maybe<TranscriptionUpsertWithoutWordsInput>;
  connect?: Maybe<TranscriptionWhereUniqueInput>;
}

export interface TrunkedCallSourceUpsertWithWhereUniqueNestedInput {
  where: TrunkedCallSourceWhereUniqueInput;
  update: TrunkedCallSourceUpdateDataInput;
  create: TrunkedCallSourceCreateInput;
}

export interface Dump1090AircraftCreateOneInput {
  create?: Maybe<Dump1090AircraftCreateInput>;
  connect?: Maybe<Dump1090AircraftWhereUniqueInput>;
}

export interface TrunkedCallSourceScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  sourceId?: Maybe<Int>;
  sourceId_not?: Maybe<Int>;
  sourceId_in?: Maybe<Int[] | Int>;
  sourceId_not_in?: Maybe<Int[] | Int>;
  sourceId_lt?: Maybe<Int>;
  sourceId_lte?: Maybe<Int>;
  sourceId_gt?: Maybe<Int>;
  sourceId_gte?: Maybe<Int>;
  time?: Maybe<DateTimeInput>;
  time_not?: Maybe<DateTimeInput>;
  time_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  time_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  time_lt?: Maybe<DateTimeInput>;
  time_lte?: Maybe<DateTimeInput>;
  time_gt?: Maybe<DateTimeInput>;
  time_gte?: Maybe<DateTimeInput>;
  position?: Maybe<Float>;
  position_not?: Maybe<Float>;
  position_in?: Maybe<Float[] | Float>;
  position_not_in?: Maybe<Float[] | Float>;
  position_lt?: Maybe<Float>;
  position_lte?: Maybe<Float>;
  position_gt?: Maybe<Float>;
  position_gte?: Maybe<Float>;
  AND?: Maybe<
    TrunkedCallSourceScalarWhereInput[] | TrunkedCallSourceScalarWhereInput
  >;
  OR?: Maybe<
    TrunkedCallSourceScalarWhereInput[] | TrunkedCallSourceScalarWhereInput
  >;
  NOT?: Maybe<
    TrunkedCallSourceScalarWhereInput[] | TrunkedCallSourceScalarWhereInput
  >;
}

export interface Dump1090AircraftUpdateOneInput {
  create?: Maybe<Dump1090AircraftCreateInput>;
  update?: Maybe<Dump1090AircraftUpdateDataInput>;
  upsert?: Maybe<Dump1090AircraftUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<Dump1090AircraftWhereUniqueInput>;
}

export interface TrunkedCallSourceUpdateManyWithWhereNestedInput {
  where: TrunkedCallSourceScalarWhereInput;
  data: TrunkedCallSourceUpdateManyDataInput;
}

export interface Dump1090AircraftUpsertNestedInput {
  update: Dump1090AircraftUpdateDataInput;
  create: Dump1090AircraftCreateInput;
}

export interface TrunkedCallSourceUpdateManyDataInput {
  sourceId?: Maybe<Int>;
  time?: Maybe<DateTimeInput>;
  position?: Maybe<Float>;
}

export interface TranscriptionCreateInput {
  id?: Maybe<ID_Input>;
  call: TrunkedCallCreateOneWithoutTranscriptionInput;
  languageModel: String;
  beta: Float;
  body: String;
  words?: Maybe<TranscriptionWordCreateManyWithoutTranscriptionInput>;
  duration: Float;
  alpha: Float;
}

export interface TrunkedCallFrequencyTimeUpdateManyInput {
  create?: Maybe<
    TrunkedCallFrequencyTimeCreateInput[] | TrunkedCallFrequencyTimeCreateInput
  >;
  update?: Maybe<
    | TrunkedCallFrequencyTimeUpdateWithWhereUniqueNestedInput[]
    | TrunkedCallFrequencyTimeUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | TrunkedCallFrequencyTimeUpsertWithWhereUniqueNestedInput[]
    | TrunkedCallFrequencyTimeUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<
    | TrunkedCallFrequencyTimeWhereUniqueInput[]
    | TrunkedCallFrequencyTimeWhereUniqueInput
  >;
  connect?: Maybe<
    | TrunkedCallFrequencyTimeWhereUniqueInput[]
    | TrunkedCallFrequencyTimeWhereUniqueInput
  >;
  set?: Maybe<
    | TrunkedCallFrequencyTimeWhereUniqueInput[]
    | TrunkedCallFrequencyTimeWhereUniqueInput
  >;
  disconnect?: Maybe<
    | TrunkedCallFrequencyTimeWhereUniqueInput[]
    | TrunkedCallFrequencyTimeWhereUniqueInput
  >;
  deleteMany?: Maybe<
    | TrunkedCallFrequencyTimeScalarWhereInput[]
    | TrunkedCallFrequencyTimeScalarWhereInput
  >;
  updateMany?: Maybe<
    | TrunkedCallFrequencyTimeUpdateManyWithWhereNestedInput[]
    | TrunkedCallFrequencyTimeUpdateManyWithWhereNestedInput
  >;
}

export interface TrunkedCallCreateWithoutTranscriptionInput {
  id?: Maybe<ID_Input>;
  frequency: Int;
  startTime: DateTimeInput;
  endTime: DateTimeInput;
  emergency?: Maybe<Boolean>;
  talkgroup?: Maybe<TrunkedTalkgroupCreateOneWithoutCallsInput>;
  system?: Maybe<TrunkedSystemCreateOneWithoutCallsInput>;
  sources?: Maybe<TrunkedCallSourceCreateManyInput>;
  duration?: Maybe<Float>;
  source?: Maybe<Int>;
  audioPath?: Maybe<String>;
  frequencyList?: Maybe<TrunkedCallFrequencyTimeCreateManyInput>;
  callHash?: Maybe<String>;
  wavPath?: Maybe<String>;
  remotePath?: Maybe<String>;
}

export interface TrunkedCallFrequencyTimeUpdateWithWhereUniqueNestedInput {
  where: TrunkedCallFrequencyTimeWhereUniqueInput;
  data: TrunkedCallFrequencyTimeUpdateDataInput;
}

export interface TrunkedSourceSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TrunkedSourceWhereInput>;
  AND?: Maybe<
    TrunkedSourceSubscriptionWhereInput[] | TrunkedSourceSubscriptionWhereInput
  >;
  OR?: Maybe<
    TrunkedSourceSubscriptionWhereInput[] | TrunkedSourceSubscriptionWhereInput
  >;
  NOT?: Maybe<
    TrunkedSourceSubscriptionWhereInput[] | TrunkedSourceSubscriptionWhereInput
  >;
}

export interface TrunkedCallFrequencyTimeUpdateDataInput {
  frequency?: Maybe<Int>;
  time?: Maybe<Int>;
  position?: Maybe<Float>;
  length?: Maybe<Int>;
  errors?: Maybe<Int>;
  spikes?: Maybe<Int>;
}

export interface TrunkedSystemWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  type?: Maybe<TrunkedSystemType>;
  type_not?: Maybe<TrunkedSystemType>;
  type_in?: Maybe<TrunkedSystemType[] | TrunkedSystemType>;
  type_not_in?: Maybe<TrunkedSystemType[] | TrunkedSystemType>;
  talkgroups_every?: Maybe<TrunkedTalkgroupWhereInput>;
  talkgroups_some?: Maybe<TrunkedTalkgroupWhereInput>;
  talkgroups_none?: Maybe<TrunkedTalkgroupWhereInput>;
  recordUnknown?: Maybe<Boolean>;
  recordUnknown_not?: Maybe<Boolean>;
  shortName?: Maybe<String>;
  shortName_not?: Maybe<String>;
  shortName_in?: Maybe<String[] | String>;
  shortName_not_in?: Maybe<String[] | String>;
  shortName_lt?: Maybe<String>;
  shortName_lte?: Maybe<String>;
  shortName_gt?: Maybe<String>;
  shortName_gte?: Maybe<String>;
  shortName_contains?: Maybe<String>;
  shortName_not_contains?: Maybe<String>;
  shortName_starts_with?: Maybe<String>;
  shortName_not_starts_with?: Maybe<String>;
  shortName_ends_with?: Maybe<String>;
  shortName_not_ends_with?: Maybe<String>;
  uploadScript?: Maybe<String>;
  uploadScript_not?: Maybe<String>;
  uploadScript_in?: Maybe<String[] | String>;
  uploadScript_not_in?: Maybe<String[] | String>;
  uploadScript_lt?: Maybe<String>;
  uploadScript_lte?: Maybe<String>;
  uploadScript_gt?: Maybe<String>;
  uploadScript_gte?: Maybe<String>;
  uploadScript_contains?: Maybe<String>;
  uploadScript_not_contains?: Maybe<String>;
  uploadScript_starts_with?: Maybe<String>;
  uploadScript_not_starts_with?: Maybe<String>;
  uploadScript_ends_with?: Maybe<String>;
  uploadScript_not_ends_with?: Maybe<String>;
  audioArchive?: Maybe<Boolean>;
  audioArchive_not?: Maybe<Boolean>;
  callLog?: Maybe<Boolean>;
  callLog_not?: Maybe<Boolean>;
  bandplan?: Maybe<TrunkedSmartnetBandplan>;
  bandplan_not?: Maybe<TrunkedSmartnetBandplan>;
  bandplan_in?: Maybe<TrunkedSmartnetBandplan[] | TrunkedSmartnetBandplan>;
  bandplan_not_in?: Maybe<TrunkedSmartnetBandplan[] | TrunkedSmartnetBandplan>;
  bandplanBase?: Maybe<Float>;
  bandplanBase_not?: Maybe<Float>;
  bandplanBase_in?: Maybe<Float[] | Float>;
  bandplanBase_not_in?: Maybe<Float[] | Float>;
  bandplanBase_lt?: Maybe<Float>;
  bandplanBase_lte?: Maybe<Float>;
  bandplanBase_gt?: Maybe<Float>;
  bandplanBase_gte?: Maybe<Float>;
  bandplanHigh?: Maybe<Float>;
  bandplanHigh_not?: Maybe<Float>;
  bandplanHigh_in?: Maybe<Float[] | Float>;
  bandplanHigh_not_in?: Maybe<Float[] | Float>;
  bandplanHigh_lt?: Maybe<Float>;
  bandplanHigh_lte?: Maybe<Float>;
  bandplanHigh_gt?: Maybe<Float>;
  bandplanHigh_gte?: Maybe<Float>;
  bandplanSpacing?: Maybe<Float>;
  bandplanSpacing_not?: Maybe<Float>;
  bandplanSpacing_in?: Maybe<Float[] | Float>;
  bandplanSpacing_not_in?: Maybe<Float[] | Float>;
  bandplanSpacing_lt?: Maybe<Float>;
  bandplanSpacing_lte?: Maybe<Float>;
  bandplanSpacing_gt?: Maybe<Float>;
  bandplanSpacing_gte?: Maybe<Float>;
  bandplanOffset?: Maybe<Float>;
  bandplanOffset_not?: Maybe<Float>;
  bandplanOffset_in?: Maybe<Float[] | Float>;
  bandplanOffset_not_in?: Maybe<Float[] | Float>;
  bandplanOffset_lt?: Maybe<Float>;
  bandplanOffset_lte?: Maybe<Float>;
  bandplanOffset_gt?: Maybe<Float>;
  bandplanOffset_gte?: Maybe<Float>;
  talkgroupDisplayFormat?: Maybe<TrunkedTalkgroupDisplayFormat>;
  talkgroupDisplayFormat_not?: Maybe<TrunkedTalkgroupDisplayFormat>;
  talkgroupDisplayFormat_in?: Maybe<
    TrunkedTalkgroupDisplayFormat[] | TrunkedTalkgroupDisplayFormat
  >;
  talkgroupDisplayFormat_not_in?: Maybe<
    TrunkedTalkgroupDisplayFormat[] | TrunkedTalkgroupDisplayFormat
  >;
  delayCreateOutput?: Maybe<Boolean>;
  delayCreateOutput_not?: Maybe<Boolean>;
  hideEncrypted?: Maybe<Boolean>;
  hideEncrypted_not?: Maybe<Boolean>;
  hideUnknownTalkgroups?: Maybe<Boolean>;
  hideUnknownTalkgroups_not?: Maybe<Boolean>;
  calls_every?: Maybe<TrunkedCallWhereInput>;
  calls_some?: Maybe<TrunkedCallWhereInput>;
  calls_none?: Maybe<TrunkedCallWhereInput>;
  AND?: Maybe<TrunkedSystemWhereInput[] | TrunkedSystemWhereInput>;
  OR?: Maybe<TrunkedSystemWhereInput[] | TrunkedSystemWhereInput>;
  NOT?: Maybe<TrunkedSystemWhereInput[] | TrunkedSystemWhereInput>;
}

export interface TrunkedCallFrequencyTimeUpsertWithWhereUniqueNestedInput {
  where: TrunkedCallFrequencyTimeWhereUniqueInput;
  update: TrunkedCallFrequencyTimeUpdateDataInput;
  create: TrunkedCallFrequencyTimeCreateInput;
}

export interface TrunkedCallSourceWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  sourceId?: Maybe<Int>;
  sourceId_not?: Maybe<Int>;
  sourceId_in?: Maybe<Int[] | Int>;
  sourceId_not_in?: Maybe<Int[] | Int>;
  sourceId_lt?: Maybe<Int>;
  sourceId_lte?: Maybe<Int>;
  sourceId_gt?: Maybe<Int>;
  sourceId_gte?: Maybe<Int>;
  time?: Maybe<DateTimeInput>;
  time_not?: Maybe<DateTimeInput>;
  time_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  time_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  time_lt?: Maybe<DateTimeInput>;
  time_lte?: Maybe<DateTimeInput>;
  time_gt?: Maybe<DateTimeInput>;
  time_gte?: Maybe<DateTimeInput>;
  position?: Maybe<Float>;
  position_not?: Maybe<Float>;
  position_in?: Maybe<Float[] | Float>;
  position_not_in?: Maybe<Float[] | Float>;
  position_lt?: Maybe<Float>;
  position_lte?: Maybe<Float>;
  position_gt?: Maybe<Float>;
  position_gte?: Maybe<Float>;
  AND?: Maybe<TrunkedCallSourceWhereInput[] | TrunkedCallSourceWhereInput>;
  OR?: Maybe<TrunkedCallSourceWhereInput[] | TrunkedCallSourceWhereInput>;
  NOT?: Maybe<TrunkedCallSourceWhereInput[] | TrunkedCallSourceWhereInput>;
}

export interface TrunkedCallFrequencyTimeScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  frequency?: Maybe<Int>;
  frequency_not?: Maybe<Int>;
  frequency_in?: Maybe<Int[] | Int>;
  frequency_not_in?: Maybe<Int[] | Int>;
  frequency_lt?: Maybe<Int>;
  frequency_lte?: Maybe<Int>;
  frequency_gt?: Maybe<Int>;
  frequency_gte?: Maybe<Int>;
  time?: Maybe<Int>;
  time_not?: Maybe<Int>;
  time_in?: Maybe<Int[] | Int>;
  time_not_in?: Maybe<Int[] | Int>;
  time_lt?: Maybe<Int>;
  time_lte?: Maybe<Int>;
  time_gt?: Maybe<Int>;
  time_gte?: Maybe<Int>;
  position?: Maybe<Float>;
  position_not?: Maybe<Float>;
  position_in?: Maybe<Float[] | Float>;
  position_not_in?: Maybe<Float[] | Float>;
  position_lt?: Maybe<Float>;
  position_lte?: Maybe<Float>;
  position_gt?: Maybe<Float>;
  position_gte?: Maybe<Float>;
  length?: Maybe<Int>;
  length_not?: Maybe<Int>;
  length_in?: Maybe<Int[] | Int>;
  length_not_in?: Maybe<Int[] | Int>;
  length_lt?: Maybe<Int>;
  length_lte?: Maybe<Int>;
  length_gt?: Maybe<Int>;
  length_gte?: Maybe<Int>;
  errors?: Maybe<Int>;
  errors_not?: Maybe<Int>;
  errors_in?: Maybe<Int[] | Int>;
  errors_not_in?: Maybe<Int[] | Int>;
  errors_lt?: Maybe<Int>;
  errors_lte?: Maybe<Int>;
  errors_gt?: Maybe<Int>;
  errors_gte?: Maybe<Int>;
  spikes?: Maybe<Int>;
  spikes_not?: Maybe<Int>;
  spikes_in?: Maybe<Int[] | Int>;
  spikes_not_in?: Maybe<Int[] | Int>;
  spikes_lt?: Maybe<Int>;
  spikes_lte?: Maybe<Int>;
  spikes_gt?: Maybe<Int>;
  spikes_gte?: Maybe<Int>;
  AND?: Maybe<
    | TrunkedCallFrequencyTimeScalarWhereInput[]
    | TrunkedCallFrequencyTimeScalarWhereInput
  >;
  OR?: Maybe<
    | TrunkedCallFrequencyTimeScalarWhereInput[]
    | TrunkedCallFrequencyTimeScalarWhereInput
  >;
  NOT?: Maybe<
    | TrunkedCallFrequencyTimeScalarWhereInput[]
    | TrunkedCallFrequencyTimeScalarWhereInput
  >;
}

export interface TrunkedCallSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TrunkedCallWhereInput>;
  AND?: Maybe<
    TrunkedCallSubscriptionWhereInput[] | TrunkedCallSubscriptionWhereInput
  >;
  OR?: Maybe<
    TrunkedCallSubscriptionWhereInput[] | TrunkedCallSubscriptionWhereInput
  >;
  NOT?: Maybe<
    TrunkedCallSubscriptionWhereInput[] | TrunkedCallSubscriptionWhereInput
  >;
}

export interface TrunkedCallFrequencyTimeUpdateManyWithWhereNestedInput {
  where: TrunkedCallFrequencyTimeScalarWhereInput;
  data: TrunkedCallFrequencyTimeUpdateManyDataInput;
}

export type Dump1090MessageWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface TrunkedCallFrequencyTimeUpdateManyDataInput {
  frequency?: Maybe<Int>;
  time?: Maybe<Int>;
  position?: Maybe<Float>;
  length?: Maybe<Int>;
  errors?: Maybe<Int>;
  spikes?: Maybe<Int>;
}

export interface TrunkedTalkgroupCreateInput {
  id?: Maybe<ID_Input>;
  decimal: Int;
  mode?: Maybe<String>;
  alphaTag?: Maybe<String>;
  description?: Maybe<String>;
  tag?: Maybe<String>;
  group?: Maybe<String>;
  priority?: Maybe<Int>;
  system?: Maybe<TrunkedSystemCreateOneWithoutTalkgroupsInput>;
  calls?: Maybe<TrunkedCallCreateManyWithoutTalkgroupInput>;
  hash: String;
}

export interface TranscriptionUpdateOneWithoutCallInput {
  create?: Maybe<TranscriptionCreateWithoutCallInput>;
  update?: Maybe<TranscriptionUpdateWithoutCallDataInput>;
  upsert?: Maybe<TranscriptionUpsertWithoutCallInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<TranscriptionWhereUniqueInput>;
}

export type TranscriptionWordWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface TranscriptionUpdateWithoutCallDataInput {
  languageModel?: Maybe<String>;
  beta?: Maybe<Float>;
  body?: Maybe<String>;
  words?: Maybe<TranscriptionWordUpdateManyWithoutTranscriptionInput>;
  duration?: Maybe<Float>;
  alpha?: Maybe<Float>;
}

export type TrunkedCallWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  callHash?: Maybe<String>;
}>;

export interface TranscriptionWordUpdateManyWithoutTranscriptionInput {
  create?: Maybe<
    | TranscriptionWordCreateWithoutTranscriptionInput[]
    | TranscriptionWordCreateWithoutTranscriptionInput
  >;
  delete?: Maybe<
    TranscriptionWordWhereUniqueInput[] | TranscriptionWordWhereUniqueInput
  >;
  connect?: Maybe<
    TranscriptionWordWhereUniqueInput[] | TranscriptionWordWhereUniqueInput
  >;
  set?: Maybe<
    TranscriptionWordWhereUniqueInput[] | TranscriptionWordWhereUniqueInput
  >;
  disconnect?: Maybe<
    TranscriptionWordWhereUniqueInput[] | TranscriptionWordWhereUniqueInput
  >;
  update?: Maybe<
    | TranscriptionWordUpdateWithWhereUniqueWithoutTranscriptionInput[]
    | TranscriptionWordUpdateWithWhereUniqueWithoutTranscriptionInput
  >;
  upsert?: Maybe<
    | TranscriptionWordUpsertWithWhereUniqueWithoutTranscriptionInput[]
    | TranscriptionWordUpsertWithWhereUniqueWithoutTranscriptionInput
  >;
  deleteMany?: Maybe<
    TranscriptionWordScalarWhereInput[] | TranscriptionWordScalarWhereInput
  >;
  updateMany?: Maybe<
    | TranscriptionWordUpdateManyWithWhereNestedInput[]
    | TranscriptionWordUpdateManyWithWhereNestedInput
  >;
}

export type TrunkedCallFrequencyTimeWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface TranscriptionWordUpdateWithWhereUniqueWithoutTranscriptionInput {
  where: TranscriptionWordWhereUniqueInput;
  data: TranscriptionWordUpdateWithoutTranscriptionDataInput;
}

export type TrunkedCallSourceWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface TranscriptionWordUpdateWithoutTranscriptionDataInput {
  text?: Maybe<String>;
  confidence?: Maybe<Float>;
  end?: Maybe<Int>;
  start?: Maybe<Int>;
}

export type TrunkedConfigWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<String>;
}>;

export interface TranscriptionWordUpsertWithWhereUniqueWithoutTranscriptionInput {
  where: TranscriptionWordWhereUniqueInput;
  update: TranscriptionWordUpdateWithoutTranscriptionDataInput;
  create: TranscriptionWordCreateWithoutTranscriptionInput;
}

export interface TrunkedSourceUpdateWithWhereUniqueNestedInput {
  where: TrunkedSourceWhereUniqueInput;
  data: TrunkedSourceUpdateDataInput;
}

export interface TranscriptionWordScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  confidence?: Maybe<Float>;
  confidence_not?: Maybe<Float>;
  confidence_in?: Maybe<Float[] | Float>;
  confidence_not_in?: Maybe<Float[] | Float>;
  confidence_lt?: Maybe<Float>;
  confidence_lte?: Maybe<Float>;
  confidence_gt?: Maybe<Float>;
  confidence_gte?: Maybe<Float>;
  end?: Maybe<Int>;
  end_not?: Maybe<Int>;
  end_in?: Maybe<Int[] | Int>;
  end_not_in?: Maybe<Int[] | Int>;
  end_lt?: Maybe<Int>;
  end_lte?: Maybe<Int>;
  end_gt?: Maybe<Int>;
  end_gte?: Maybe<Int>;
  start?: Maybe<Int>;
  start_not?: Maybe<Int>;
  start_in?: Maybe<Int[] | Int>;
  start_not_in?: Maybe<Int[] | Int>;
  start_lt?: Maybe<Int>;
  start_lte?: Maybe<Int>;
  start_gt?: Maybe<Int>;
  start_gte?: Maybe<Int>;
  AND?: Maybe<
    TranscriptionWordScalarWhereInput[] | TranscriptionWordScalarWhereInput
  >;
  OR?: Maybe<
    TranscriptionWordScalarWhereInput[] | TranscriptionWordScalarWhereInput
  >;
  NOT?: Maybe<
    TranscriptionWordScalarWhereInput[] | TranscriptionWordScalarWhereInput
  >;
}

export interface Dump1090AircraftWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  IcaoID?: Maybe<String>;
  IcaoID_not?: Maybe<String>;
  IcaoID_in?: Maybe<String[] | String>;
  IcaoID_not_in?: Maybe<String[] | String>;
  IcaoID_lt?: Maybe<String>;
  IcaoID_lte?: Maybe<String>;
  IcaoID_gt?: Maybe<String>;
  IcaoID_gte?: Maybe<String>;
  IcaoID_contains?: Maybe<String>;
  IcaoID_not_contains?: Maybe<String>;
  IcaoID_starts_with?: Maybe<String>;
  IcaoID_not_starts_with?: Maybe<String>;
  IcaoID_ends_with?: Maybe<String>;
  IcaoID_not_ends_with?: Maybe<String>;
  AND?: Maybe<Dump1090AircraftWhereInput[] | Dump1090AircraftWhereInput>;
  OR?: Maybe<Dump1090AircraftWhereInput[] | Dump1090AircraftWhereInput>;
  NOT?: Maybe<Dump1090AircraftWhereInput[] | Dump1090AircraftWhereInput>;
}

export interface TranscriptionWordUpdateManyWithWhereNestedInput {
  where: TranscriptionWordScalarWhereInput;
  data: TranscriptionWordUpdateManyDataInput;
}

export interface TrunkedSourceCreateManyInput {
  create?: Maybe<TrunkedSourceCreateInput[] | TrunkedSourceCreateInput>;
  connect?: Maybe<
    TrunkedSourceWhereUniqueInput[] | TrunkedSourceWhereUniqueInput
  >;
}

export interface TranscriptionWordUpdateManyDataInput {
  text?: Maybe<String>;
  confidence?: Maybe<Float>;
  end?: Maybe<Int>;
  start?: Maybe<Int>;
}

export interface TrunkedCallSourceUpdateInput {
  sourceId?: Maybe<Int>;
  time?: Maybe<DateTimeInput>;
  position?: Maybe<Float>;
}

export interface TranscriptionUpsertWithoutCallInput {
  update: TranscriptionUpdateWithoutCallDataInput;
  create: TranscriptionCreateWithoutCallInput;
}

export interface TrunkedCallUpdateManyMutationInput {
  frequency?: Maybe<Int>;
  startTime?: Maybe<DateTimeInput>;
  endTime?: Maybe<DateTimeInput>;
  emergency?: Maybe<Boolean>;
  duration?: Maybe<Float>;
  source?: Maybe<Int>;
  audioPath?: Maybe<String>;
  callHash?: Maybe<String>;
  wavPath?: Maybe<String>;
  remotePath?: Maybe<String>;
}

export interface TrunkedCallUpsertWithWhereUniqueWithoutSystemInput {
  where: TrunkedCallWhereUniqueInput;
  update: TrunkedCallUpdateWithoutSystemDataInput;
  create: TrunkedCallCreateWithoutSystemInput;
}

export interface TranscriptionWordUpdateManyMutationInput {
  text?: Maybe<String>;
  confidence?: Maybe<Float>;
  end?: Maybe<Int>;
  start?: Maybe<Int>;
}

export interface TrunkedCallScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  frequency?: Maybe<Int>;
  frequency_not?: Maybe<Int>;
  frequency_in?: Maybe<Int[] | Int>;
  frequency_not_in?: Maybe<Int[] | Int>;
  frequency_lt?: Maybe<Int>;
  frequency_lte?: Maybe<Int>;
  frequency_gt?: Maybe<Int>;
  frequency_gte?: Maybe<Int>;
  startTime?: Maybe<DateTimeInput>;
  startTime_not?: Maybe<DateTimeInput>;
  startTime_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startTime_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startTime_lt?: Maybe<DateTimeInput>;
  startTime_lte?: Maybe<DateTimeInput>;
  startTime_gt?: Maybe<DateTimeInput>;
  startTime_gte?: Maybe<DateTimeInput>;
  endTime?: Maybe<DateTimeInput>;
  endTime_not?: Maybe<DateTimeInput>;
  endTime_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endTime_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endTime_lt?: Maybe<DateTimeInput>;
  endTime_lte?: Maybe<DateTimeInput>;
  endTime_gt?: Maybe<DateTimeInput>;
  endTime_gte?: Maybe<DateTimeInput>;
  emergency?: Maybe<Boolean>;
  emergency_not?: Maybe<Boolean>;
  duration?: Maybe<Float>;
  duration_not?: Maybe<Float>;
  duration_in?: Maybe<Float[] | Float>;
  duration_not_in?: Maybe<Float[] | Float>;
  duration_lt?: Maybe<Float>;
  duration_lte?: Maybe<Float>;
  duration_gt?: Maybe<Float>;
  duration_gte?: Maybe<Float>;
  source?: Maybe<Int>;
  source_not?: Maybe<Int>;
  source_in?: Maybe<Int[] | Int>;
  source_not_in?: Maybe<Int[] | Int>;
  source_lt?: Maybe<Int>;
  source_lte?: Maybe<Int>;
  source_gt?: Maybe<Int>;
  source_gte?: Maybe<Int>;
  audioPath?: Maybe<String>;
  audioPath_not?: Maybe<String>;
  audioPath_in?: Maybe<String[] | String>;
  audioPath_not_in?: Maybe<String[] | String>;
  audioPath_lt?: Maybe<String>;
  audioPath_lte?: Maybe<String>;
  audioPath_gt?: Maybe<String>;
  audioPath_gte?: Maybe<String>;
  audioPath_contains?: Maybe<String>;
  audioPath_not_contains?: Maybe<String>;
  audioPath_starts_with?: Maybe<String>;
  audioPath_not_starts_with?: Maybe<String>;
  audioPath_ends_with?: Maybe<String>;
  audioPath_not_ends_with?: Maybe<String>;
  callHash?: Maybe<String>;
  callHash_not?: Maybe<String>;
  callHash_in?: Maybe<String[] | String>;
  callHash_not_in?: Maybe<String[] | String>;
  callHash_lt?: Maybe<String>;
  callHash_lte?: Maybe<String>;
  callHash_gt?: Maybe<String>;
  callHash_gte?: Maybe<String>;
  callHash_contains?: Maybe<String>;
  callHash_not_contains?: Maybe<String>;
  callHash_starts_with?: Maybe<String>;
  callHash_not_starts_with?: Maybe<String>;
  callHash_ends_with?: Maybe<String>;
  callHash_not_ends_with?: Maybe<String>;
  wavPath?: Maybe<String>;
  wavPath_not?: Maybe<String>;
  wavPath_in?: Maybe<String[] | String>;
  wavPath_not_in?: Maybe<String[] | String>;
  wavPath_lt?: Maybe<String>;
  wavPath_lte?: Maybe<String>;
  wavPath_gt?: Maybe<String>;
  wavPath_gte?: Maybe<String>;
  wavPath_contains?: Maybe<String>;
  wavPath_not_contains?: Maybe<String>;
  wavPath_starts_with?: Maybe<String>;
  wavPath_not_starts_with?: Maybe<String>;
  wavPath_ends_with?: Maybe<String>;
  wavPath_not_ends_with?: Maybe<String>;
  remotePath?: Maybe<String>;
  remotePath_not?: Maybe<String>;
  remotePath_in?: Maybe<String[] | String>;
  remotePath_not_in?: Maybe<String[] | String>;
  remotePath_lt?: Maybe<String>;
  remotePath_lte?: Maybe<String>;
  remotePath_gt?: Maybe<String>;
  remotePath_gte?: Maybe<String>;
  remotePath_contains?: Maybe<String>;
  remotePath_not_contains?: Maybe<String>;
  remotePath_starts_with?: Maybe<String>;
  remotePath_not_starts_with?: Maybe<String>;
  remotePath_ends_with?: Maybe<String>;
  remotePath_not_ends_with?: Maybe<String>;
  AND?: Maybe<TrunkedCallScalarWhereInput[] | TrunkedCallScalarWhereInput>;
  OR?: Maybe<TrunkedCallScalarWhereInput[] | TrunkedCallScalarWhereInput>;
  NOT?: Maybe<TrunkedCallScalarWhereInput[] | TrunkedCallScalarWhereInput>;
}

export interface Dump1090AircraftUpdateInput {
  IcaoID?: Maybe<String>;
}

export interface TrunkedCallUpdateManyWithWhereNestedInput {
  where: TrunkedCallScalarWhereInput;
  data: TrunkedCallUpdateManyDataInput;
}

export interface Dump1090MessageCreateInput {
  id?: Maybe<ID_Input>;
  messageType: Dump1090MessageType;
  transmissionType: Dump1090TransmissionType;
  aircraft?: Maybe<Dump1090AircraftCreateOneInput>;
  generated: DateTimeInput;
  logged: DateTimeInput;
  flightId?: Maybe<String>;
  squawk?: Maybe<String>;
  alert?: Maybe<Boolean>;
  emergency?: Maybe<Boolean>;
  isOnGround?: Maybe<Boolean>;
  latitude?: Maybe<Float>;
  longitude?: Maybe<Float>;
  verticalRate?: Maybe<Int>;
  track?: Maybe<Int>;
  groupSpeed?: Maybe<Int>;
  callsign?: Maybe<String>;
  altitude?: Maybe<Int>;
}

export interface TrunkedCallUpdateManyDataInput {
  frequency?: Maybe<Int>;
  startTime?: Maybe<DateTimeInput>;
  endTime?: Maybe<DateTimeInput>;
  emergency?: Maybe<Boolean>;
  duration?: Maybe<Float>;
  source?: Maybe<Int>;
  audioPath?: Maybe<String>;
  callHash?: Maybe<String>;
  wavPath?: Maybe<String>;
  remotePath?: Maybe<String>;
}

export interface Dump1090AircraftUpdateDataInput {
  IcaoID?: Maybe<String>;
}

export interface TrunkedSystemUpsertWithoutTalkgroupsInput {
  update: TrunkedSystemUpdateWithoutTalkgroupsDataInput;
  create: TrunkedSystemCreateWithoutTalkgroupsInput;
}

export interface TrunkedCallCreateOneWithoutTranscriptionInput {
  create?: Maybe<TrunkedCallCreateWithoutTranscriptionInput>;
  connect?: Maybe<TrunkedCallWhereUniqueInput>;
}

export interface TrunkedTalkgroupUpsertWithoutCallsInput {
  update: TrunkedTalkgroupUpdateWithoutCallsDataInput;
  create: TrunkedTalkgroupCreateWithoutCallsInput;
}

export interface TrunkedCallSourceSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TrunkedCallSourceWhereInput>;
  AND?: Maybe<
    | TrunkedCallSourceSubscriptionWhereInput[]
    | TrunkedCallSourceSubscriptionWhereInput
  >;
  OR?: Maybe<
    | TrunkedCallSourceSubscriptionWhereInput[]
    | TrunkedCallSourceSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | TrunkedCallSourceSubscriptionWhereInput[]
    | TrunkedCallSourceSubscriptionWhereInput
  >;
}

export interface TrunkedSystemUpdateOneWithoutCallsInput {
  create?: Maybe<TrunkedSystemCreateWithoutCallsInput>;
  update?: Maybe<TrunkedSystemUpdateWithoutCallsDataInput>;
  upsert?: Maybe<TrunkedSystemUpsertWithoutCallsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<TrunkedSystemWhereUniqueInput>;
}

export interface TranscriptionWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  call?: Maybe<TrunkedCallWhereInput>;
  languageModel?: Maybe<String>;
  languageModel_not?: Maybe<String>;
  languageModel_in?: Maybe<String[] | String>;
  languageModel_not_in?: Maybe<String[] | String>;
  languageModel_lt?: Maybe<String>;
  languageModel_lte?: Maybe<String>;
  languageModel_gt?: Maybe<String>;
  languageModel_gte?: Maybe<String>;
  languageModel_contains?: Maybe<String>;
  languageModel_not_contains?: Maybe<String>;
  languageModel_starts_with?: Maybe<String>;
  languageModel_not_starts_with?: Maybe<String>;
  languageModel_ends_with?: Maybe<String>;
  languageModel_not_ends_with?: Maybe<String>;
  beta?: Maybe<Float>;
  beta_not?: Maybe<Float>;
  beta_in?: Maybe<Float[] | Float>;
  beta_not_in?: Maybe<Float[] | Float>;
  beta_lt?: Maybe<Float>;
  beta_lte?: Maybe<Float>;
  beta_gt?: Maybe<Float>;
  beta_gte?: Maybe<Float>;
  body?: Maybe<String>;
  body_not?: Maybe<String>;
  body_in?: Maybe<String[] | String>;
  body_not_in?: Maybe<String[] | String>;
  body_lt?: Maybe<String>;
  body_lte?: Maybe<String>;
  body_gt?: Maybe<String>;
  body_gte?: Maybe<String>;
  body_contains?: Maybe<String>;
  body_not_contains?: Maybe<String>;
  body_starts_with?: Maybe<String>;
  body_not_starts_with?: Maybe<String>;
  body_ends_with?: Maybe<String>;
  body_not_ends_with?: Maybe<String>;
  words_every?: Maybe<TranscriptionWordWhereInput>;
  words_some?: Maybe<TranscriptionWordWhereInput>;
  words_none?: Maybe<TranscriptionWordWhereInput>;
  duration?: Maybe<Float>;
  duration_not?: Maybe<Float>;
  duration_in?: Maybe<Float[] | Float>;
  duration_not_in?: Maybe<Float[] | Float>;
  duration_lt?: Maybe<Float>;
  duration_lte?: Maybe<Float>;
  duration_gt?: Maybe<Float>;
  duration_gte?: Maybe<Float>;
  alpha?: Maybe<Float>;
  alpha_not?: Maybe<Float>;
  alpha_in?: Maybe<Float[] | Float>;
  alpha_not_in?: Maybe<Float[] | Float>;
  alpha_lt?: Maybe<Float>;
  alpha_lte?: Maybe<Float>;
  alpha_gt?: Maybe<Float>;
  alpha_gte?: Maybe<Float>;
  AND?: Maybe<TranscriptionWhereInput[] | TranscriptionWhereInput>;
  OR?: Maybe<TranscriptionWhereInput[] | TranscriptionWhereInput>;
  NOT?: Maybe<TranscriptionWhereInput[] | TranscriptionWhereInput>;
}

export interface TrunkedSystemUpdateWithoutCallsDataInput {
  controlChannels?: Maybe<TrunkedSystemUpdatecontrolChannelsInput>;
  channels?: Maybe<TrunkedSystemUpdatechannelsInput>;
  type?: Maybe<TrunkedSystemType>;
  alphatags?: Maybe<TrunkedSystemUpdatealphatagsInput>;
  talkgroups?: Maybe<TrunkedTalkgroupUpdateManyWithoutSystemInput>;
  recordUnknown?: Maybe<Boolean>;
  shortName?: Maybe<String>;
  uploadScript?: Maybe<String>;
  audioArchive?: Maybe<Boolean>;
  callLog?: Maybe<Boolean>;
  bandplan?: Maybe<TrunkedSmartnetBandplan>;
  bandplanBase?: Maybe<Float>;
  bandplanHigh?: Maybe<Float>;
  bandplanSpacing?: Maybe<Float>;
  bandplanOffset?: Maybe<Float>;
  talkgroupDisplayFormat?: Maybe<TrunkedTalkgroupDisplayFormat>;
  delayCreateOutput?: Maybe<Boolean>;
  hideEncrypted?: Maybe<Boolean>;
  hideUnknownTalkgroups?: Maybe<Boolean>;
}

export interface TrunkedTalkgroupUpdateManyMutationInput {
  decimal?: Maybe<Int>;
  mode?: Maybe<String>;
  alphaTag?: Maybe<String>;
  description?: Maybe<String>;
  tag?: Maybe<String>;
  group?: Maybe<String>;
  priority?: Maybe<Int>;
  hash?: Maybe<String>;
}

export interface TrunkedTalkgroupUpdateManyWithoutSystemInput {
  create?: Maybe<
    | TrunkedTalkgroupCreateWithoutSystemInput[]
    | TrunkedTalkgroupCreateWithoutSystemInput
  >;
  delete?: Maybe<
    TrunkedTalkgroupWhereUniqueInput[] | TrunkedTalkgroupWhereUniqueInput
  >;
  connect?: Maybe<
    TrunkedTalkgroupWhereUniqueInput[] | TrunkedTalkgroupWhereUniqueInput
  >;
  set?: Maybe<
    TrunkedTalkgroupWhereUniqueInput[] | TrunkedTalkgroupWhereUniqueInput
  >;
  disconnect?: Maybe<
    TrunkedTalkgroupWhereUniqueInput[] | TrunkedTalkgroupWhereUniqueInput
  >;
  update?: Maybe<
    | TrunkedTalkgroupUpdateWithWhereUniqueWithoutSystemInput[]
    | TrunkedTalkgroupUpdateWithWhereUniqueWithoutSystemInput
  >;
  upsert?: Maybe<
    | TrunkedTalkgroupUpsertWithWhereUniqueWithoutSystemInput[]
    | TrunkedTalkgroupUpsertWithWhereUniqueWithoutSystemInput
  >;
  deleteMany?: Maybe<
    TrunkedTalkgroupScalarWhereInput[] | TrunkedTalkgroupScalarWhereInput
  >;
  updateMany?: Maybe<
    | TrunkedTalkgroupUpdateManyWithWhereNestedInput[]
    | TrunkedTalkgroupUpdateManyWithWhereNestedInput
  >;
}

export interface TrunkedConfigUpdateManyMutationInput {
  name?: Maybe<String>;
  defaultMode?: Maybe<TrunkedDefaultMode>;
  captureDir?: Maybe<String>;
  callTimeout?: Maybe<Int>;
  logFile?: Maybe<Boolean>;
  frequencyFormat?: Maybe<TrunkedFrequencyFormat>;
  controlWarnRate?: Maybe<Int>;
  statusAsString?: Maybe<Boolean>;
}

export interface TrunkedTalkgroupUpdateWithWhereUniqueWithoutSystemInput {
  where: TrunkedTalkgroupWhereUniqueInput;
  data: TrunkedTalkgroupUpdateWithoutSystemDataInput;
}

export interface TrunkedSystemUpdateWithWhereUniqueNestedInput {
  where: TrunkedSystemWhereUniqueInput;
  data: TrunkedSystemUpdateDataInput;
}

export interface TrunkedTalkgroupUpdateWithoutSystemDataInput {
  decimal?: Maybe<Int>;
  mode?: Maybe<String>;
  alphaTag?: Maybe<String>;
  description?: Maybe<String>;
  tag?: Maybe<String>;
  group?: Maybe<String>;
  priority?: Maybe<Int>;
  calls?: Maybe<TrunkedCallUpdateManyWithoutTalkgroupInput>;
  hash?: Maybe<String>;
}

export interface TrunkedSourceWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  center?: Maybe<Float>;
  center_not?: Maybe<Float>;
  center_in?: Maybe<Float[] | Float>;
  center_not_in?: Maybe<Float[] | Float>;
  center_lt?: Maybe<Float>;
  center_lte?: Maybe<Float>;
  center_gt?: Maybe<Float>;
  center_gte?: Maybe<Float>;
  rate?: Maybe<Float>;
  rate_not?: Maybe<Float>;
  rate_in?: Maybe<Float[] | Float>;
  rate_not_in?: Maybe<Float[] | Float>;
  rate_lt?: Maybe<Float>;
  rate_lte?: Maybe<Float>;
  rate_gt?: Maybe<Float>;
  rate_gte?: Maybe<Float>;
  squelch?: Maybe<Float>;
  squelch_not?: Maybe<Float>;
  squelch_in?: Maybe<Float[] | Float>;
  squelch_not_in?: Maybe<Float[] | Float>;
  squelch_lt?: Maybe<Float>;
  squelch_lte?: Maybe<Float>;
  squelch_gt?: Maybe<Float>;
  squelch_gte?: Maybe<Float>;
  error?: Maybe<Float>;
  error_not?: Maybe<Float>;
  error_in?: Maybe<Float[] | Float>;
  error_not_in?: Maybe<Float[] | Float>;
  error_lt?: Maybe<Float>;
  error_lte?: Maybe<Float>;
  error_gt?: Maybe<Float>;
  error_gte?: Maybe<Float>;
  gain?: Maybe<Float>;
  gain_not?: Maybe<Float>;
  gain_in?: Maybe<Float[] | Float>;
  gain_not_in?: Maybe<Float[] | Float>;
  gain_lt?: Maybe<Float>;
  gain_lte?: Maybe<Float>;
  gain_gt?: Maybe<Float>;
  gain_gte?: Maybe<Float>;
  digitalRecorders?: Maybe<Float>;
  digitalRecorders_not?: Maybe<Float>;
  digitalRecorders_in?: Maybe<Float[] | Float>;
  digitalRecorders_not_in?: Maybe<Float[] | Float>;
  digitalRecorders_lt?: Maybe<Float>;
  digitalRecorders_lte?: Maybe<Float>;
  digitalRecorders_gt?: Maybe<Float>;
  digitalRecorders_gte?: Maybe<Float>;
  digitalLevels?: Maybe<Float>;
  digitalLevels_not?: Maybe<Float>;
  digitalLevels_in?: Maybe<Float[] | Float>;
  digitalLevels_not_in?: Maybe<Float[] | Float>;
  digitalLevels_lt?: Maybe<Float>;
  digitalLevels_lte?: Maybe<Float>;
  digitalLevels_gt?: Maybe<Float>;
  digitalLevels_gte?: Maybe<Float>;
  analogRecorders?: Maybe<Float>;
  analogRecorders_not?: Maybe<Float>;
  analogRecorders_in?: Maybe<Float[] | Float>;
  analogRecorders_not_in?: Maybe<Float[] | Float>;
  analogRecorders_lt?: Maybe<Float>;
  analogRecorders_lte?: Maybe<Float>;
  analogRecorders_gt?: Maybe<Float>;
  analogRecorders_gte?: Maybe<Float>;
  analogLevels?: Maybe<Float>;
  analogLevels_not?: Maybe<Float>;
  analogLevels_in?: Maybe<Float[] | Float>;
  analogLevels_not_in?: Maybe<Float[] | Float>;
  analogLevels_lt?: Maybe<Float>;
  analogLevels_lte?: Maybe<Float>;
  analogLevels_gt?: Maybe<Float>;
  analogLevels_gte?: Maybe<Float>;
  device?: Maybe<String>;
  device_not?: Maybe<String>;
  device_in?: Maybe<String[] | String>;
  device_not_in?: Maybe<String[] | String>;
  device_lt?: Maybe<String>;
  device_lte?: Maybe<String>;
  device_gt?: Maybe<String>;
  device_gte?: Maybe<String>;
  device_contains?: Maybe<String>;
  device_not_contains?: Maybe<String>;
  device_starts_with?: Maybe<String>;
  device_not_starts_with?: Maybe<String>;
  device_ends_with?: Maybe<String>;
  device_not_ends_with?: Maybe<String>;
  modulation?: Maybe<TrunkedModulation>;
  modulation_not?: Maybe<TrunkedModulation>;
  modulation_in?: Maybe<TrunkedModulation[] | TrunkedModulation>;
  modulation_not_in?: Maybe<TrunkedModulation[] | TrunkedModulation>;
  AND?: Maybe<TrunkedSourceWhereInput[] | TrunkedSourceWhereInput>;
  OR?: Maybe<TrunkedSourceWhereInput[] | TrunkedSourceWhereInput>;
  NOT?: Maybe<TrunkedSourceWhereInput[] | TrunkedSourceWhereInput>;
}

export interface TrunkedCallUpdateManyWithoutTalkgroupInput {
  create?: Maybe<
    | TrunkedCallCreateWithoutTalkgroupInput[]
    | TrunkedCallCreateWithoutTalkgroupInput
  >;
  delete?: Maybe<TrunkedCallWhereUniqueInput[] | TrunkedCallWhereUniqueInput>;
  connect?: Maybe<TrunkedCallWhereUniqueInput[] | TrunkedCallWhereUniqueInput>;
  set?: Maybe<TrunkedCallWhereUniqueInput[] | TrunkedCallWhereUniqueInput>;
  disconnect?: Maybe<
    TrunkedCallWhereUniqueInput[] | TrunkedCallWhereUniqueInput
  >;
  update?: Maybe<
    | TrunkedCallUpdateWithWhereUniqueWithoutTalkgroupInput[]
    | TrunkedCallUpdateWithWhereUniqueWithoutTalkgroupInput
  >;
  upsert?: Maybe<
    | TrunkedCallUpsertWithWhereUniqueWithoutTalkgroupInput[]
    | TrunkedCallUpsertWithWhereUniqueWithoutTalkgroupInput
  >;
  deleteMany?: Maybe<
    TrunkedCallScalarWhereInput[] | TrunkedCallScalarWhereInput
  >;
  updateMany?: Maybe<
    | TrunkedCallUpdateManyWithWhereNestedInput[]
    | TrunkedCallUpdateManyWithWhereNestedInput
  >;
}

export interface TrunkedSystemCreateManyInput {
  create?: Maybe<TrunkedSystemCreateInput[] | TrunkedSystemCreateInput>;
  connect?: Maybe<
    TrunkedSystemWhereUniqueInput[] | TrunkedSystemWhereUniqueInput
  >;
}

export interface TrunkedCallUpdateWithWhereUniqueWithoutTalkgroupInput {
  where: TrunkedCallWhereUniqueInput;
  data: TrunkedCallUpdateWithoutTalkgroupDataInput;
}

export type TrunkedSystemWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  shortName?: Maybe<String>;
}>;

export interface TrunkedCallUpdateWithoutTalkgroupDataInput {
  frequency?: Maybe<Int>;
  startTime?: Maybe<DateTimeInput>;
  endTime?: Maybe<DateTimeInput>;
  emergency?: Maybe<Boolean>;
  system?: Maybe<TrunkedSystemUpdateOneWithoutCallsInput>;
  sources?: Maybe<TrunkedCallSourceUpdateManyInput>;
  duration?: Maybe<Float>;
  source?: Maybe<Int>;
  audioPath?: Maybe<String>;
  frequencyList?: Maybe<TrunkedCallFrequencyTimeUpdateManyInput>;
  callHash?: Maybe<String>;
  wavPath?: Maybe<String>;
  transcription?: Maybe<TranscriptionUpdateOneWithoutCallInput>;
  remotePath?: Maybe<String>;
}

export interface Dump1090MessageUpdateInput {
  messageType?: Maybe<Dump1090MessageType>;
  transmissionType?: Maybe<Dump1090TransmissionType>;
  aircraft?: Maybe<Dump1090AircraftUpdateOneInput>;
  generated?: Maybe<DateTimeInput>;
  logged?: Maybe<DateTimeInput>;
  flightId?: Maybe<String>;
  squawk?: Maybe<String>;
  alert?: Maybe<Boolean>;
  emergency?: Maybe<Boolean>;
  isOnGround?: Maybe<Boolean>;
  latitude?: Maybe<Float>;
  longitude?: Maybe<Float>;
  verticalRate?: Maybe<Int>;
  track?: Maybe<Int>;
  groupSpeed?: Maybe<Int>;
  callsign?: Maybe<String>;
  altitude?: Maybe<Int>;
}

export interface TrunkedCallUpsertWithWhereUniqueWithoutTalkgroupInput {
  where: TrunkedCallWhereUniqueInput;
  update: TrunkedCallUpdateWithoutTalkgroupDataInput;
  create: TrunkedCallCreateWithoutTalkgroupInput;
}

export interface TrunkedTalkgroupSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TrunkedTalkgroupWhereInput>;
  AND?: Maybe<
    | TrunkedTalkgroupSubscriptionWhereInput[]
    | TrunkedTalkgroupSubscriptionWhereInput
  >;
  OR?: Maybe<
    | TrunkedTalkgroupSubscriptionWhereInput[]
    | TrunkedTalkgroupSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | TrunkedTalkgroupSubscriptionWhereInput[]
    | TrunkedTalkgroupSubscriptionWhereInput
  >;
}

export interface TrunkedTalkgroupUpsertWithWhereUniqueWithoutSystemInput {
  where: TrunkedTalkgroupWhereUniqueInput;
  update: TrunkedTalkgroupUpdateWithoutSystemDataInput;
  create: TrunkedTalkgroupCreateWithoutSystemInput;
}

export interface TranscriptionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TranscriptionWhereInput>;
  AND?: Maybe<
    TranscriptionSubscriptionWhereInput[] | TranscriptionSubscriptionWhereInput
  >;
  OR?: Maybe<
    TranscriptionSubscriptionWhereInput[] | TranscriptionSubscriptionWhereInput
  >;
  NOT?: Maybe<
    TranscriptionSubscriptionWhereInput[] | TranscriptionSubscriptionWhereInput
  >;
}

export interface TrunkedTalkgroupScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  decimal?: Maybe<Int>;
  decimal_not?: Maybe<Int>;
  decimal_in?: Maybe<Int[] | Int>;
  decimal_not_in?: Maybe<Int[] | Int>;
  decimal_lt?: Maybe<Int>;
  decimal_lte?: Maybe<Int>;
  decimal_gt?: Maybe<Int>;
  decimal_gte?: Maybe<Int>;
  mode?: Maybe<String>;
  mode_not?: Maybe<String>;
  mode_in?: Maybe<String[] | String>;
  mode_not_in?: Maybe<String[] | String>;
  mode_lt?: Maybe<String>;
  mode_lte?: Maybe<String>;
  mode_gt?: Maybe<String>;
  mode_gte?: Maybe<String>;
  mode_contains?: Maybe<String>;
  mode_not_contains?: Maybe<String>;
  mode_starts_with?: Maybe<String>;
  mode_not_starts_with?: Maybe<String>;
  mode_ends_with?: Maybe<String>;
  mode_not_ends_with?: Maybe<String>;
  alphaTag?: Maybe<String>;
  alphaTag_not?: Maybe<String>;
  alphaTag_in?: Maybe<String[] | String>;
  alphaTag_not_in?: Maybe<String[] | String>;
  alphaTag_lt?: Maybe<String>;
  alphaTag_lte?: Maybe<String>;
  alphaTag_gt?: Maybe<String>;
  alphaTag_gte?: Maybe<String>;
  alphaTag_contains?: Maybe<String>;
  alphaTag_not_contains?: Maybe<String>;
  alphaTag_starts_with?: Maybe<String>;
  alphaTag_not_starts_with?: Maybe<String>;
  alphaTag_ends_with?: Maybe<String>;
  alphaTag_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  tag?: Maybe<String>;
  tag_not?: Maybe<String>;
  tag_in?: Maybe<String[] | String>;
  tag_not_in?: Maybe<String[] | String>;
  tag_lt?: Maybe<String>;
  tag_lte?: Maybe<String>;
  tag_gt?: Maybe<String>;
  tag_gte?: Maybe<String>;
  tag_contains?: Maybe<String>;
  tag_not_contains?: Maybe<String>;
  tag_starts_with?: Maybe<String>;
  tag_not_starts_with?: Maybe<String>;
  tag_ends_with?: Maybe<String>;
  tag_not_ends_with?: Maybe<String>;
  group?: Maybe<String>;
  group_not?: Maybe<String>;
  group_in?: Maybe<String[] | String>;
  group_not_in?: Maybe<String[] | String>;
  group_lt?: Maybe<String>;
  group_lte?: Maybe<String>;
  group_gt?: Maybe<String>;
  group_gte?: Maybe<String>;
  group_contains?: Maybe<String>;
  group_not_contains?: Maybe<String>;
  group_starts_with?: Maybe<String>;
  group_not_starts_with?: Maybe<String>;
  group_ends_with?: Maybe<String>;
  group_not_ends_with?: Maybe<String>;
  priority?: Maybe<Int>;
  priority_not?: Maybe<Int>;
  priority_in?: Maybe<Int[] | Int>;
  priority_not_in?: Maybe<Int[] | Int>;
  priority_lt?: Maybe<Int>;
  priority_lte?: Maybe<Int>;
  priority_gt?: Maybe<Int>;
  priority_gte?: Maybe<Int>;
  hash?: Maybe<String>;
  hash_not?: Maybe<String>;
  hash_in?: Maybe<String[] | String>;
  hash_not_in?: Maybe<String[] | String>;
  hash_lt?: Maybe<String>;
  hash_lte?: Maybe<String>;
  hash_gt?: Maybe<String>;
  hash_gte?: Maybe<String>;
  hash_contains?: Maybe<String>;
  hash_not_contains?: Maybe<String>;
  hash_starts_with?: Maybe<String>;
  hash_not_starts_with?: Maybe<String>;
  hash_ends_with?: Maybe<String>;
  hash_not_ends_with?: Maybe<String>;
  AND?: Maybe<
    TrunkedTalkgroupScalarWhereInput[] | TrunkedTalkgroupScalarWhereInput
  >;
  OR?: Maybe<
    TrunkedTalkgroupScalarWhereInput[] | TrunkedTalkgroupScalarWhereInput
  >;
  NOT?: Maybe<
    TrunkedTalkgroupScalarWhereInput[] | TrunkedTalkgroupScalarWhereInput
  >;
}

export interface TrunkedSystemScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  type?: Maybe<TrunkedSystemType>;
  type_not?: Maybe<TrunkedSystemType>;
  type_in?: Maybe<TrunkedSystemType[] | TrunkedSystemType>;
  type_not_in?: Maybe<TrunkedSystemType[] | TrunkedSystemType>;
  recordUnknown?: Maybe<Boolean>;
  recordUnknown_not?: Maybe<Boolean>;
  shortName?: Maybe<String>;
  shortName_not?: Maybe<String>;
  shortName_in?: Maybe<String[] | String>;
  shortName_not_in?: Maybe<String[] | String>;
  shortName_lt?: Maybe<String>;
  shortName_lte?: Maybe<String>;
  shortName_gt?: Maybe<String>;
  shortName_gte?: Maybe<String>;
  shortName_contains?: Maybe<String>;
  shortName_not_contains?: Maybe<String>;
  shortName_starts_with?: Maybe<String>;
  shortName_not_starts_with?: Maybe<String>;
  shortName_ends_with?: Maybe<String>;
  shortName_not_ends_with?: Maybe<String>;
  uploadScript?: Maybe<String>;
  uploadScript_not?: Maybe<String>;
  uploadScript_in?: Maybe<String[] | String>;
  uploadScript_not_in?: Maybe<String[] | String>;
  uploadScript_lt?: Maybe<String>;
  uploadScript_lte?: Maybe<String>;
  uploadScript_gt?: Maybe<String>;
  uploadScript_gte?: Maybe<String>;
  uploadScript_contains?: Maybe<String>;
  uploadScript_not_contains?: Maybe<String>;
  uploadScript_starts_with?: Maybe<String>;
  uploadScript_not_starts_with?: Maybe<String>;
  uploadScript_ends_with?: Maybe<String>;
  uploadScript_not_ends_with?: Maybe<String>;
  audioArchive?: Maybe<Boolean>;
  audioArchive_not?: Maybe<Boolean>;
  callLog?: Maybe<Boolean>;
  callLog_not?: Maybe<Boolean>;
  bandplan?: Maybe<TrunkedSmartnetBandplan>;
  bandplan_not?: Maybe<TrunkedSmartnetBandplan>;
  bandplan_in?: Maybe<TrunkedSmartnetBandplan[] | TrunkedSmartnetBandplan>;
  bandplan_not_in?: Maybe<TrunkedSmartnetBandplan[] | TrunkedSmartnetBandplan>;
  bandplanBase?: Maybe<Float>;
  bandplanBase_not?: Maybe<Float>;
  bandplanBase_in?: Maybe<Float[] | Float>;
  bandplanBase_not_in?: Maybe<Float[] | Float>;
  bandplanBase_lt?: Maybe<Float>;
  bandplanBase_lte?: Maybe<Float>;
  bandplanBase_gt?: Maybe<Float>;
  bandplanBase_gte?: Maybe<Float>;
  bandplanHigh?: Maybe<Float>;
  bandplanHigh_not?: Maybe<Float>;
  bandplanHigh_in?: Maybe<Float[] | Float>;
  bandplanHigh_not_in?: Maybe<Float[] | Float>;
  bandplanHigh_lt?: Maybe<Float>;
  bandplanHigh_lte?: Maybe<Float>;
  bandplanHigh_gt?: Maybe<Float>;
  bandplanHigh_gte?: Maybe<Float>;
  bandplanSpacing?: Maybe<Float>;
  bandplanSpacing_not?: Maybe<Float>;
  bandplanSpacing_in?: Maybe<Float[] | Float>;
  bandplanSpacing_not_in?: Maybe<Float[] | Float>;
  bandplanSpacing_lt?: Maybe<Float>;
  bandplanSpacing_lte?: Maybe<Float>;
  bandplanSpacing_gt?: Maybe<Float>;
  bandplanSpacing_gte?: Maybe<Float>;
  bandplanOffset?: Maybe<Float>;
  bandplanOffset_not?: Maybe<Float>;
  bandplanOffset_in?: Maybe<Float[] | Float>;
  bandplanOffset_not_in?: Maybe<Float[] | Float>;
  bandplanOffset_lt?: Maybe<Float>;
  bandplanOffset_lte?: Maybe<Float>;
  bandplanOffset_gt?: Maybe<Float>;
  bandplanOffset_gte?: Maybe<Float>;
  talkgroupDisplayFormat?: Maybe<TrunkedTalkgroupDisplayFormat>;
  talkgroupDisplayFormat_not?: Maybe<TrunkedTalkgroupDisplayFormat>;
  talkgroupDisplayFormat_in?: Maybe<
    TrunkedTalkgroupDisplayFormat[] | TrunkedTalkgroupDisplayFormat
  >;
  talkgroupDisplayFormat_not_in?: Maybe<
    TrunkedTalkgroupDisplayFormat[] | TrunkedTalkgroupDisplayFormat
  >;
  delayCreateOutput?: Maybe<Boolean>;
  delayCreateOutput_not?: Maybe<Boolean>;
  hideEncrypted?: Maybe<Boolean>;
  hideEncrypted_not?: Maybe<Boolean>;
  hideUnknownTalkgroups?: Maybe<Boolean>;
  hideUnknownTalkgroups_not?: Maybe<Boolean>;
  AND?: Maybe<TrunkedSystemScalarWhereInput[] | TrunkedSystemScalarWhereInput>;
  OR?: Maybe<TrunkedSystemScalarWhereInput[] | TrunkedSystemScalarWhereInput>;
  NOT?: Maybe<TrunkedSystemScalarWhereInput[] | TrunkedSystemScalarWhereInput>;
}

export interface TrunkedTalkgroupUpdateManyWithWhereNestedInput {
  where: TrunkedTalkgroupScalarWhereInput;
  data: TrunkedTalkgroupUpdateManyDataInput;
}

export interface TrunkedConfigUpdateInput {
  name?: Maybe<String>;
  sources?: Maybe<TrunkedSourceUpdateManyInput>;
  systems?: Maybe<TrunkedSystemUpdateManyInput>;
  defaultMode?: Maybe<TrunkedDefaultMode>;
  captureDir?: Maybe<String>;
  callTimeout?: Maybe<Int>;
  logFile?: Maybe<Boolean>;
  frequencyFormat?: Maybe<TrunkedFrequencyFormat>;
  controlWarnRate?: Maybe<Int>;
  statusAsString?: Maybe<Boolean>;
}

export interface TrunkedTalkgroupUpdateManyDataInput {
  decimal?: Maybe<Int>;
  mode?: Maybe<String>;
  alphaTag?: Maybe<String>;
  description?: Maybe<String>;
  tag?: Maybe<String>;
  group?: Maybe<String>;
  priority?: Maybe<Int>;
  hash?: Maybe<String>;
}

export type TrunkedTalkgroupWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  hash?: Maybe<String>;
}>;

export interface TrunkedSystemUpsertWithoutCallsInput {
  update: TrunkedSystemUpdateWithoutCallsDataInput;
  create: TrunkedSystemCreateWithoutCallsInput;
}

export interface Dump1090MessageUpdateManyMutationInput {
  messageType?: Maybe<Dump1090MessageType>;
  transmissionType?: Maybe<Dump1090TransmissionType>;
  generated?: Maybe<DateTimeInput>;
  logged?: Maybe<DateTimeInput>;
  flightId?: Maybe<String>;
  squawk?: Maybe<String>;
  alert?: Maybe<Boolean>;
  emergency?: Maybe<Boolean>;
  isOnGround?: Maybe<Boolean>;
  latitude?: Maybe<Float>;
  longitude?: Maybe<Float>;
  verticalRate?: Maybe<Int>;
  track?: Maybe<Int>;
  groupSpeed?: Maybe<Int>;
  callsign?: Maybe<String>;
  altitude?: Maybe<Int>;
}

export interface TranscriptionCreateOneWithoutWordsInput {
  create?: Maybe<TranscriptionCreateWithoutWordsInput>;
  connect?: Maybe<TranscriptionWhereUniqueInput>;
}

export interface TranscriptionWordCreateInput {
  id?: Maybe<ID_Input>;
  text: String;
  transcription: TranscriptionCreateOneWithoutWordsInput;
  confidence: Float;
  end: Int;
  start: Int;
}

export interface TranscriptionUpdateManyMutationInput {
  languageModel?: Maybe<String>;
  beta?: Maybe<Float>;
  body?: Maybe<String>;
  duration?: Maybe<Float>;
  alpha?: Maybe<Float>;
}

export interface TrunkedCallUpsertWithoutTranscriptionInput {
  update: TrunkedCallUpdateWithoutTranscriptionDataInput;
  create: TrunkedCallCreateWithoutTranscriptionInput;
}

export interface Dump1090MessageWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  messageType?: Maybe<Dump1090MessageType>;
  messageType_not?: Maybe<Dump1090MessageType>;
  messageType_in?: Maybe<Dump1090MessageType[] | Dump1090MessageType>;
  messageType_not_in?: Maybe<Dump1090MessageType[] | Dump1090MessageType>;
  transmissionType?: Maybe<Dump1090TransmissionType>;
  transmissionType_not?: Maybe<Dump1090TransmissionType>;
  transmissionType_in?: Maybe<
    Dump1090TransmissionType[] | Dump1090TransmissionType
  >;
  transmissionType_not_in?: Maybe<
    Dump1090TransmissionType[] | Dump1090TransmissionType
  >;
  aircraft?: Maybe<Dump1090AircraftWhereInput>;
  generated?: Maybe<DateTimeInput>;
  generated_not?: Maybe<DateTimeInput>;
  generated_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  generated_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  generated_lt?: Maybe<DateTimeInput>;
  generated_lte?: Maybe<DateTimeInput>;
  generated_gt?: Maybe<DateTimeInput>;
  generated_gte?: Maybe<DateTimeInput>;
  logged?: Maybe<DateTimeInput>;
  logged_not?: Maybe<DateTimeInput>;
  logged_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  logged_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  logged_lt?: Maybe<DateTimeInput>;
  logged_lte?: Maybe<DateTimeInput>;
  logged_gt?: Maybe<DateTimeInput>;
  logged_gte?: Maybe<DateTimeInput>;
  flightId?: Maybe<String>;
  flightId_not?: Maybe<String>;
  flightId_in?: Maybe<String[] | String>;
  flightId_not_in?: Maybe<String[] | String>;
  flightId_lt?: Maybe<String>;
  flightId_lte?: Maybe<String>;
  flightId_gt?: Maybe<String>;
  flightId_gte?: Maybe<String>;
  flightId_contains?: Maybe<String>;
  flightId_not_contains?: Maybe<String>;
  flightId_starts_with?: Maybe<String>;
  flightId_not_starts_with?: Maybe<String>;
  flightId_ends_with?: Maybe<String>;
  flightId_not_ends_with?: Maybe<String>;
  squawk?: Maybe<String>;
  squawk_not?: Maybe<String>;
  squawk_in?: Maybe<String[] | String>;
  squawk_not_in?: Maybe<String[] | String>;
  squawk_lt?: Maybe<String>;
  squawk_lte?: Maybe<String>;
  squawk_gt?: Maybe<String>;
  squawk_gte?: Maybe<String>;
  squawk_contains?: Maybe<String>;
  squawk_not_contains?: Maybe<String>;
  squawk_starts_with?: Maybe<String>;
  squawk_not_starts_with?: Maybe<String>;
  squawk_ends_with?: Maybe<String>;
  squawk_not_ends_with?: Maybe<String>;
  alert?: Maybe<Boolean>;
  alert_not?: Maybe<Boolean>;
  emergency?: Maybe<Boolean>;
  emergency_not?: Maybe<Boolean>;
  isOnGround?: Maybe<Boolean>;
  isOnGround_not?: Maybe<Boolean>;
  latitude?: Maybe<Float>;
  latitude_not?: Maybe<Float>;
  latitude_in?: Maybe<Float[] | Float>;
  latitude_not_in?: Maybe<Float[] | Float>;
  latitude_lt?: Maybe<Float>;
  latitude_lte?: Maybe<Float>;
  latitude_gt?: Maybe<Float>;
  latitude_gte?: Maybe<Float>;
  longitude?: Maybe<Float>;
  longitude_not?: Maybe<Float>;
  longitude_in?: Maybe<Float[] | Float>;
  longitude_not_in?: Maybe<Float[] | Float>;
  longitude_lt?: Maybe<Float>;
  longitude_lte?: Maybe<Float>;
  longitude_gt?: Maybe<Float>;
  longitude_gte?: Maybe<Float>;
  verticalRate?: Maybe<Int>;
  verticalRate_not?: Maybe<Int>;
  verticalRate_in?: Maybe<Int[] | Int>;
  verticalRate_not_in?: Maybe<Int[] | Int>;
  verticalRate_lt?: Maybe<Int>;
  verticalRate_lte?: Maybe<Int>;
  verticalRate_gt?: Maybe<Int>;
  verticalRate_gte?: Maybe<Int>;
  track?: Maybe<Int>;
  track_not?: Maybe<Int>;
  track_in?: Maybe<Int[] | Int>;
  track_not_in?: Maybe<Int[] | Int>;
  track_lt?: Maybe<Int>;
  track_lte?: Maybe<Int>;
  track_gt?: Maybe<Int>;
  track_gte?: Maybe<Int>;
  groupSpeed?: Maybe<Int>;
  groupSpeed_not?: Maybe<Int>;
  groupSpeed_in?: Maybe<Int[] | Int>;
  groupSpeed_not_in?: Maybe<Int[] | Int>;
  groupSpeed_lt?: Maybe<Int>;
  groupSpeed_lte?: Maybe<Int>;
  groupSpeed_gt?: Maybe<Int>;
  groupSpeed_gte?: Maybe<Int>;
  callsign?: Maybe<String>;
  callsign_not?: Maybe<String>;
  callsign_in?: Maybe<String[] | String>;
  callsign_not_in?: Maybe<String[] | String>;
  callsign_lt?: Maybe<String>;
  callsign_lte?: Maybe<String>;
  callsign_gt?: Maybe<String>;
  callsign_gte?: Maybe<String>;
  callsign_contains?: Maybe<String>;
  callsign_not_contains?: Maybe<String>;
  callsign_starts_with?: Maybe<String>;
  callsign_not_starts_with?: Maybe<String>;
  callsign_ends_with?: Maybe<String>;
  callsign_not_ends_with?: Maybe<String>;
  altitude?: Maybe<Int>;
  altitude_not?: Maybe<Int>;
  altitude_in?: Maybe<Int[] | Int>;
  altitude_not_in?: Maybe<Int[] | Int>;
  altitude_lt?: Maybe<Int>;
  altitude_lte?: Maybe<Int>;
  altitude_gt?: Maybe<Int>;
  altitude_gte?: Maybe<Int>;
  AND?: Maybe<Dump1090MessageWhereInput[] | Dump1090MessageWhereInput>;
  OR?: Maybe<Dump1090MessageWhereInput[] | Dump1090MessageWhereInput>;
  NOT?: Maybe<Dump1090MessageWhereInput[] | Dump1090MessageWhereInput>;
}

export interface TranscriptionUpdateWithoutWordsDataInput {
  call?: Maybe<TrunkedCallUpdateOneRequiredWithoutTranscriptionInput>;
  languageModel?: Maybe<String>;
  beta?: Maybe<Float>;
  body?: Maybe<String>;
  duration?: Maybe<Float>;
  alpha?: Maybe<Float>;
}

export type TrunkedSourceWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface TrunkedSourceUpdateManyWithWhereNestedInput {
  where: TrunkedSourceScalarWhereInput;
  data: TrunkedSourceUpdateManyDataInput;
}

export interface TrunkedSystemUpdateInput {
  controlChannels?: Maybe<TrunkedSystemUpdatecontrolChannelsInput>;
  channels?: Maybe<TrunkedSystemUpdatechannelsInput>;
  type?: Maybe<TrunkedSystemType>;
  alphatags?: Maybe<TrunkedSystemUpdatealphatagsInput>;
  talkgroups?: Maybe<TrunkedTalkgroupUpdateManyWithoutSystemInput>;
  recordUnknown?: Maybe<Boolean>;
  shortName?: Maybe<String>;
  uploadScript?: Maybe<String>;
  audioArchive?: Maybe<Boolean>;
  callLog?: Maybe<Boolean>;
  bandplan?: Maybe<TrunkedSmartnetBandplan>;
  bandplanBase?: Maybe<Float>;
  bandplanHigh?: Maybe<Float>;
  bandplanSpacing?: Maybe<Float>;
  bandplanOffset?: Maybe<Float>;
  talkgroupDisplayFormat?: Maybe<TrunkedTalkgroupDisplayFormat>;
  delayCreateOutput?: Maybe<Boolean>;
  hideEncrypted?: Maybe<Boolean>;
  hideUnknownTalkgroups?: Maybe<Boolean>;
  calls?: Maybe<TrunkedCallUpdateManyWithoutSystemInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface TrunkedTalkgroupPreviousValues {
  id: ID_Output;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
  decimal: Int;
  mode?: String;
  alphaTag?: String;
  description?: String;
  tag?: String;
  group?: String;
  priority: Int;
  hash: String;
}

export interface TrunkedTalkgroupPreviousValuesPromise
  extends Promise<TrunkedTalkgroupPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  decimal: () => Promise<Int>;
  mode: () => Promise<String>;
  alphaTag: () => Promise<String>;
  description: () => Promise<String>;
  tag: () => Promise<String>;
  group: () => Promise<String>;
  priority: () => Promise<Int>;
  hash: () => Promise<String>;
}

export interface TrunkedTalkgroupPreviousValuesSubscription
  extends Promise<AsyncIterator<TrunkedTalkgroupPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  decimal: () => Promise<AsyncIterator<Int>>;
  mode: () => Promise<AsyncIterator<String>>;
  alphaTag: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  tag: () => Promise<AsyncIterator<String>>;
  group: () => Promise<AsyncIterator<String>>;
  priority: () => Promise<AsyncIterator<Int>>;
  hash: () => Promise<AsyncIterator<String>>;
}

export interface Dump1090AircraftEdge {
  node: Dump1090Aircraft;
  cursor: String;
}

export interface Dump1090AircraftEdgePromise
  extends Promise<Dump1090AircraftEdge>,
    Fragmentable {
  node: <T = Dump1090AircraftPromise>() => T;
  cursor: () => Promise<String>;
}

export interface Dump1090AircraftEdgeSubscription
  extends Promise<AsyncIterator<Dump1090AircraftEdge>>,
    Fragmentable {
  node: <T = Dump1090AircraftSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateDump1090Message {
  count: Int;
}

export interface AggregateDump1090MessagePromise
  extends Promise<AggregateDump1090Message>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDump1090MessageSubscription
  extends Promise<AsyncIterator<AggregateDump1090Message>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TranscriptionWord {
  id: ID_Output;
  text: String;
  confidence: Float;
  end: Int;
  start: Int;
}

export interface TranscriptionWordPromise
  extends Promise<TranscriptionWord>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  text: () => Promise<String>;
  transcription: <T = TranscriptionPromise>() => T;
  confidence: () => Promise<Float>;
  end: () => Promise<Int>;
  start: () => Promise<Int>;
}

export interface TranscriptionWordSubscription
  extends Promise<AsyncIterator<TranscriptionWord>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  text: () => Promise<AsyncIterator<String>>;
  transcription: <T = TranscriptionSubscription>() => T;
  confidence: () => Promise<AsyncIterator<Float>>;
  end: () => Promise<AsyncIterator<Int>>;
  start: () => Promise<AsyncIterator<Int>>;
}

export interface TranscriptionWordNullablePromise
  extends Promise<TranscriptionWord | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  text: () => Promise<String>;
  transcription: <T = TranscriptionPromise>() => T;
  confidence: () => Promise<Float>;
  end: () => Promise<Int>;
  start: () => Promise<Int>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface AggregateDump1090Aircraft {
  count: Int;
}

export interface AggregateDump1090AircraftPromise
  extends Promise<AggregateDump1090Aircraft>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDump1090AircraftSubscription
  extends Promise<AsyncIterator<AggregateDump1090Aircraft>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TrunkedTalkgroupEdge {
  node: TrunkedTalkgroup;
  cursor: String;
}

export interface TrunkedTalkgroupEdgePromise
  extends Promise<TrunkedTalkgroupEdge>,
    Fragmentable {
  node: <T = TrunkedTalkgroupPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TrunkedTalkgroupEdgeSubscription
  extends Promise<AsyncIterator<TrunkedTalkgroupEdge>>,
    Fragmentable {
  node: <T = TrunkedTalkgroupSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface TrunkedCallFrequencyTime {
  id: ID_Output;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
  frequency: Int;
  time: Int;
  position: Float;
  length: Int;
  errors: Int;
  spikes: Int;
}

export interface TrunkedCallFrequencyTimePromise
  extends Promise<TrunkedCallFrequencyTime>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  frequency: () => Promise<Int>;
  time: () => Promise<Int>;
  position: () => Promise<Float>;
  length: () => Promise<Int>;
  errors: () => Promise<Int>;
  spikes: () => Promise<Int>;
}

export interface TrunkedCallFrequencyTimeSubscription
  extends Promise<AsyncIterator<TrunkedCallFrequencyTime>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  frequency: () => Promise<AsyncIterator<Int>>;
  time: () => Promise<AsyncIterator<Int>>;
  position: () => Promise<AsyncIterator<Float>>;
  length: () => Promise<AsyncIterator<Int>>;
  errors: () => Promise<AsyncIterator<Int>>;
  spikes: () => Promise<AsyncIterator<Int>>;
}

export interface TrunkedCallFrequencyTimeNullablePromise
  extends Promise<TrunkedCallFrequencyTime | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  frequency: () => Promise<Int>;
  time: () => Promise<Int>;
  position: () => Promise<Float>;
  length: () => Promise<Int>;
  errors: () => Promise<Int>;
  spikes: () => Promise<Int>;
}

export interface AggregateTrunkedSystem {
  count: Int;
}

export interface AggregateTrunkedSystemPromise
  extends Promise<AggregateTrunkedSystem>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTrunkedSystemSubscription
  extends Promise<AsyncIterator<AggregateTrunkedSystem>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateTrunkedTalkgroup {
  count: Int;
}

export interface AggregateTrunkedTalkgroupPromise
  extends Promise<AggregateTrunkedTalkgroup>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTrunkedTalkgroupSubscription
  extends Promise<AsyncIterator<AggregateTrunkedTalkgroup>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TrunkedSourcePreviousValues {
  id: ID_Output;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
  center: Float;
  rate: Float;
  squelch: Float;
  error: Float;
  gain: Float;
  digitalRecorders: Float;
  digitalLevels?: Float;
  analogRecorders: Float;
  analogLevels?: Float;
  device: String;
  modulation: TrunkedModulation;
}

export interface TrunkedSourcePreviousValuesPromise
  extends Promise<TrunkedSourcePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  center: () => Promise<Float>;
  rate: () => Promise<Float>;
  squelch: () => Promise<Float>;
  error: () => Promise<Float>;
  gain: () => Promise<Float>;
  digitalRecorders: () => Promise<Float>;
  digitalLevels: () => Promise<Float>;
  analogRecorders: () => Promise<Float>;
  analogLevels: () => Promise<Float>;
  device: () => Promise<String>;
  modulation: () => Promise<TrunkedModulation>;
}

export interface TrunkedSourcePreviousValuesSubscription
  extends Promise<AsyncIterator<TrunkedSourcePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  center: () => Promise<AsyncIterator<Float>>;
  rate: () => Promise<AsyncIterator<Float>>;
  squelch: () => Promise<AsyncIterator<Float>>;
  error: () => Promise<AsyncIterator<Float>>;
  gain: () => Promise<AsyncIterator<Float>>;
  digitalRecorders: () => Promise<AsyncIterator<Float>>;
  digitalLevels: () => Promise<AsyncIterator<Float>>;
  analogRecorders: () => Promise<AsyncIterator<Float>>;
  analogLevels: () => Promise<AsyncIterator<Float>>;
  device: () => Promise<AsyncIterator<String>>;
  modulation: () => Promise<AsyncIterator<TrunkedModulation>>;
}

export interface TrunkedTalkgroupConnection {
  pageInfo: PageInfo;
  edges: TrunkedTalkgroupEdge[];
}

export interface TrunkedTalkgroupConnectionPromise
  extends Promise<TrunkedTalkgroupConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TrunkedTalkgroupEdge>>() => T;
  aggregate: <T = AggregateTrunkedTalkgroupPromise>() => T;
}

export interface TrunkedTalkgroupConnectionSubscription
  extends Promise<AsyncIterator<TrunkedTalkgroupConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TrunkedTalkgroupEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTrunkedTalkgroupSubscription>() => T;
}

export interface TrunkedSystemConnection {
  pageInfo: PageInfo;
  edges: TrunkedSystemEdge[];
}

export interface TrunkedSystemConnectionPromise
  extends Promise<TrunkedSystemConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TrunkedSystemEdge>>() => T;
  aggregate: <T = AggregateTrunkedSystemPromise>() => T;
}

export interface TrunkedSystemConnectionSubscription
  extends Promise<AsyncIterator<TrunkedSystemConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TrunkedSystemEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTrunkedSystemSubscription>() => T;
}

export interface TrunkedSystemEdge {
  node: TrunkedSystem;
  cursor: String;
}

export interface TrunkedSystemEdgePromise
  extends Promise<TrunkedSystemEdge>,
    Fragmentable {
  node: <T = TrunkedSystemPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TrunkedSystemEdgeSubscription
  extends Promise<AsyncIterator<TrunkedSystemEdge>>,
    Fragmentable {
  node: <T = TrunkedSystemSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface TrunkedSourceConnection {
  pageInfo: PageInfo;
  edges: TrunkedSourceEdge[];
}

export interface TrunkedSourceConnectionPromise
  extends Promise<TrunkedSourceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TrunkedSourceEdge>>() => T;
  aggregate: <T = AggregateTrunkedSourcePromise>() => T;
}

export interface TrunkedSourceConnectionSubscription
  extends Promise<AsyncIterator<TrunkedSourceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TrunkedSourceEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTrunkedSourceSubscription>() => T;
}

export interface AggregateTrunkedSource {
  count: Int;
}

export interface AggregateTrunkedSourcePromise
  extends Promise<AggregateTrunkedSource>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTrunkedSourceSubscription
  extends Promise<AsyncIterator<AggregateTrunkedSource>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TrunkedConfigEdge {
  node: TrunkedConfig;
  cursor: String;
}

export interface TrunkedConfigEdgePromise
  extends Promise<TrunkedConfigEdge>,
    Fragmentable {
  node: <T = TrunkedConfigPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TrunkedConfigEdgeSubscription
  extends Promise<AsyncIterator<TrunkedConfigEdge>>,
    Fragmentable {
  node: <T = TrunkedConfigSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Dump1090AircraftSubscriptionPayload {
  mutation: MutationType;
  node: Dump1090Aircraft;
  updatedFields: String[];
  previousValues: Dump1090AircraftPreviousValues;
}

export interface Dump1090AircraftSubscriptionPayloadPromise
  extends Promise<Dump1090AircraftSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Dump1090AircraftPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = Dump1090AircraftPreviousValuesPromise>() => T;
}

export interface Dump1090AircraftSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<Dump1090AircraftSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = Dump1090AircraftSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = Dump1090AircraftPreviousValuesSubscription>() => T;
}

export interface Dump1090Aircraft {
  id: ID_Output;
  IcaoID?: String;
}

export interface Dump1090AircraftPromise
  extends Promise<Dump1090Aircraft>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  IcaoID: () => Promise<String>;
}

export interface Dump1090AircraftSubscription
  extends Promise<AsyncIterator<Dump1090Aircraft>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  IcaoID: () => Promise<AsyncIterator<String>>;
}

export interface Dump1090AircraftNullablePromise
  extends Promise<Dump1090Aircraft | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  IcaoID: () => Promise<String>;
}

export interface Dump1090AircraftPreviousValues {
  id: ID_Output;
  IcaoID?: String;
}

export interface Dump1090AircraftPreviousValuesPromise
  extends Promise<Dump1090AircraftPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  IcaoID: () => Promise<String>;
}

export interface Dump1090AircraftPreviousValuesSubscription
  extends Promise<AsyncIterator<Dump1090AircraftPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  IcaoID: () => Promise<AsyncIterator<String>>;
}

export interface Dump1090AircraftConnection {
  pageInfo: PageInfo;
  edges: Dump1090AircraftEdge[];
}

export interface Dump1090AircraftConnectionPromise
  extends Promise<Dump1090AircraftConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<Dump1090AircraftEdge>>() => T;
  aggregate: <T = AggregateDump1090AircraftPromise>() => T;
}

export interface Dump1090AircraftConnectionSubscription
  extends Promise<AsyncIterator<Dump1090AircraftConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<Dump1090AircraftEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDump1090AircraftSubscription>() => T;
}

export interface TrunkedCallSource {
  id: ID_Output;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
  sourceId?: Int;
  time?: DateTimeOutput;
  position?: Float;
}

export interface TrunkedCallSourcePromise
  extends Promise<TrunkedCallSource>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  sourceId: () => Promise<Int>;
  time: () => Promise<DateTimeOutput>;
  position: () => Promise<Float>;
}

export interface TrunkedCallSourceSubscription
  extends Promise<AsyncIterator<TrunkedCallSource>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sourceId: () => Promise<AsyncIterator<Int>>;
  time: () => Promise<AsyncIterator<DateTimeOutput>>;
  position: () => Promise<AsyncIterator<Float>>;
}

export interface TrunkedCallSourceNullablePromise
  extends Promise<TrunkedCallSource | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  sourceId: () => Promise<Int>;
  time: () => Promise<DateTimeOutput>;
  position: () => Promise<Float>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface Dump1090MessageSubscriptionPayload {
  mutation: MutationType;
  node: Dump1090Message;
  updatedFields: String[];
  previousValues: Dump1090MessagePreviousValues;
}

export interface Dump1090MessageSubscriptionPayloadPromise
  extends Promise<Dump1090MessageSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Dump1090MessagePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = Dump1090MessagePreviousValuesPromise>() => T;
}

export interface Dump1090MessageSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<Dump1090MessageSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = Dump1090MessageSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = Dump1090MessagePreviousValuesSubscription>() => T;
}

export interface TrunkedConfig {
  id: ID_Output;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
  name: String;
  defaultMode: TrunkedDefaultMode;
  captureDir: String;
  callTimeout: Int;
  logFile: Boolean;
  frequencyFormat: TrunkedFrequencyFormat;
  controlWarnRate: Int;
  statusAsString: Boolean;
}

export interface TrunkedConfigPromise
  extends Promise<TrunkedConfig>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  sources: <T = FragmentableArray<TrunkedSource>>(args?: {
    where?: TrunkedSourceWhereInput;
    orderBy?: TrunkedSourceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  systems: <T = FragmentableArray<TrunkedSystem>>(args?: {
    where?: TrunkedSystemWhereInput;
    orderBy?: TrunkedSystemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  defaultMode: () => Promise<TrunkedDefaultMode>;
  captureDir: () => Promise<String>;
  callTimeout: () => Promise<Int>;
  logFile: () => Promise<Boolean>;
  frequencyFormat: () => Promise<TrunkedFrequencyFormat>;
  controlWarnRate: () => Promise<Int>;
  statusAsString: () => Promise<Boolean>;
}

export interface TrunkedConfigSubscription
  extends Promise<AsyncIterator<TrunkedConfig>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  sources: <T = Promise<AsyncIterator<TrunkedSourceSubscription>>>(args?: {
    where?: TrunkedSourceWhereInput;
    orderBy?: TrunkedSourceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  systems: <T = Promise<AsyncIterator<TrunkedSystemSubscription>>>(args?: {
    where?: TrunkedSystemWhereInput;
    orderBy?: TrunkedSystemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  defaultMode: () => Promise<AsyncIterator<TrunkedDefaultMode>>;
  captureDir: () => Promise<AsyncIterator<String>>;
  callTimeout: () => Promise<AsyncIterator<Int>>;
  logFile: () => Promise<AsyncIterator<Boolean>>;
  frequencyFormat: () => Promise<AsyncIterator<TrunkedFrequencyFormat>>;
  controlWarnRate: () => Promise<AsyncIterator<Int>>;
  statusAsString: () => Promise<AsyncIterator<Boolean>>;
}

export interface TrunkedConfigNullablePromise
  extends Promise<TrunkedConfig | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  sources: <T = FragmentableArray<TrunkedSource>>(args?: {
    where?: TrunkedSourceWhereInput;
    orderBy?: TrunkedSourceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  systems: <T = FragmentableArray<TrunkedSystem>>(args?: {
    where?: TrunkedSystemWhereInput;
    orderBy?: TrunkedSystemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  defaultMode: () => Promise<TrunkedDefaultMode>;
  captureDir: () => Promise<String>;
  callTimeout: () => Promise<Int>;
  logFile: () => Promise<Boolean>;
  frequencyFormat: () => Promise<TrunkedFrequencyFormat>;
  controlWarnRate: () => Promise<Int>;
  statusAsString: () => Promise<Boolean>;
}

export interface Dump1090MessagePreviousValues {
  id: ID_Output;
  messageType: Dump1090MessageType;
  transmissionType: Dump1090TransmissionType;
  generated: DateTimeOutput;
  logged: DateTimeOutput;
  flightId?: String;
  squawk?: String;
  alert?: Boolean;
  emergency?: Boolean;
  isOnGround?: Boolean;
  latitude?: Float;
  longitude?: Float;
  verticalRate?: Int;
  track?: Int;
  groupSpeed?: Int;
  callsign?: String;
  altitude?: Int;
}

export interface Dump1090MessagePreviousValuesPromise
  extends Promise<Dump1090MessagePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  messageType: () => Promise<Dump1090MessageType>;
  transmissionType: () => Promise<Dump1090TransmissionType>;
  generated: () => Promise<DateTimeOutput>;
  logged: () => Promise<DateTimeOutput>;
  flightId: () => Promise<String>;
  squawk: () => Promise<String>;
  alert: () => Promise<Boolean>;
  emergency: () => Promise<Boolean>;
  isOnGround: () => Promise<Boolean>;
  latitude: () => Promise<Float>;
  longitude: () => Promise<Float>;
  verticalRate: () => Promise<Int>;
  track: () => Promise<Int>;
  groupSpeed: () => Promise<Int>;
  callsign: () => Promise<String>;
  altitude: () => Promise<Int>;
}

export interface Dump1090MessagePreviousValuesSubscription
  extends Promise<AsyncIterator<Dump1090MessagePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  messageType: () => Promise<AsyncIterator<Dump1090MessageType>>;
  transmissionType: () => Promise<AsyncIterator<Dump1090TransmissionType>>;
  generated: () => Promise<AsyncIterator<DateTimeOutput>>;
  logged: () => Promise<AsyncIterator<DateTimeOutput>>;
  flightId: () => Promise<AsyncIterator<String>>;
  squawk: () => Promise<AsyncIterator<String>>;
  alert: () => Promise<AsyncIterator<Boolean>>;
  emergency: () => Promise<AsyncIterator<Boolean>>;
  isOnGround: () => Promise<AsyncIterator<Boolean>>;
  latitude: () => Promise<AsyncIterator<Float>>;
  longitude: () => Promise<AsyncIterator<Float>>;
  verticalRate: () => Promise<AsyncIterator<Int>>;
  track: () => Promise<AsyncIterator<Int>>;
  groupSpeed: () => Promise<AsyncIterator<Int>>;
  callsign: () => Promise<AsyncIterator<String>>;
  altitude: () => Promise<AsyncIterator<Int>>;
}

export interface TrunkedCallSourceEdge {
  node: TrunkedCallSource;
  cursor: String;
}

export interface TrunkedCallSourceEdgePromise
  extends Promise<TrunkedCallSourceEdge>,
    Fragmentable {
  node: <T = TrunkedCallSourcePromise>() => T;
  cursor: () => Promise<String>;
}

export interface TrunkedCallSourceEdgeSubscription
  extends Promise<AsyncIterator<TrunkedCallSourceEdge>>,
    Fragmentable {
  node: <T = TrunkedCallSourceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Dump1090Message {
  id: ID_Output;
  messageType: Dump1090MessageType;
  transmissionType: Dump1090TransmissionType;
  generated: DateTimeOutput;
  logged: DateTimeOutput;
  flightId?: String;
  squawk?: String;
  alert?: Boolean;
  emergency?: Boolean;
  isOnGround?: Boolean;
  latitude?: Float;
  longitude?: Float;
  verticalRate?: Int;
  track?: Int;
  groupSpeed?: Int;
  callsign?: String;
  altitude?: Int;
}

export interface Dump1090MessagePromise
  extends Promise<Dump1090Message>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  messageType: () => Promise<Dump1090MessageType>;
  transmissionType: () => Promise<Dump1090TransmissionType>;
  aircraft: <T = Dump1090AircraftPromise>() => T;
  generated: () => Promise<DateTimeOutput>;
  logged: () => Promise<DateTimeOutput>;
  flightId: () => Promise<String>;
  squawk: () => Promise<String>;
  alert: () => Promise<Boolean>;
  emergency: () => Promise<Boolean>;
  isOnGround: () => Promise<Boolean>;
  latitude: () => Promise<Float>;
  longitude: () => Promise<Float>;
  verticalRate: () => Promise<Int>;
  track: () => Promise<Int>;
  groupSpeed: () => Promise<Int>;
  callsign: () => Promise<String>;
  altitude: () => Promise<Int>;
}

export interface Dump1090MessageSubscription
  extends Promise<AsyncIterator<Dump1090Message>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  messageType: () => Promise<AsyncIterator<Dump1090MessageType>>;
  transmissionType: () => Promise<AsyncIterator<Dump1090TransmissionType>>;
  aircraft: <T = Dump1090AircraftSubscription>() => T;
  generated: () => Promise<AsyncIterator<DateTimeOutput>>;
  logged: () => Promise<AsyncIterator<DateTimeOutput>>;
  flightId: () => Promise<AsyncIterator<String>>;
  squawk: () => Promise<AsyncIterator<String>>;
  alert: () => Promise<AsyncIterator<Boolean>>;
  emergency: () => Promise<AsyncIterator<Boolean>>;
  isOnGround: () => Promise<AsyncIterator<Boolean>>;
  latitude: () => Promise<AsyncIterator<Float>>;
  longitude: () => Promise<AsyncIterator<Float>>;
  verticalRate: () => Promise<AsyncIterator<Int>>;
  track: () => Promise<AsyncIterator<Int>>;
  groupSpeed: () => Promise<AsyncIterator<Int>>;
  callsign: () => Promise<AsyncIterator<String>>;
  altitude: () => Promise<AsyncIterator<Int>>;
}

export interface Dump1090MessageNullablePromise
  extends Promise<Dump1090Message | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  messageType: () => Promise<Dump1090MessageType>;
  transmissionType: () => Promise<Dump1090TransmissionType>;
  aircraft: <T = Dump1090AircraftPromise>() => T;
  generated: () => Promise<DateTimeOutput>;
  logged: () => Promise<DateTimeOutput>;
  flightId: () => Promise<String>;
  squawk: () => Promise<String>;
  alert: () => Promise<Boolean>;
  emergency: () => Promise<Boolean>;
  isOnGround: () => Promise<Boolean>;
  latitude: () => Promise<Float>;
  longitude: () => Promise<Float>;
  verticalRate: () => Promise<Int>;
  track: () => Promise<Int>;
  groupSpeed: () => Promise<Int>;
  callsign: () => Promise<String>;
  altitude: () => Promise<Int>;
}

export interface AggregateTrunkedCallFrequencyTime {
  count: Int;
}

export interface AggregateTrunkedCallFrequencyTimePromise
  extends Promise<AggregateTrunkedCallFrequencyTime>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTrunkedCallFrequencyTimeSubscription
  extends Promise<AsyncIterator<AggregateTrunkedCallFrequencyTime>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TranscriptionSubscriptionPayload {
  mutation: MutationType;
  node: Transcription;
  updatedFields: String[];
  previousValues: TranscriptionPreviousValues;
}

export interface TranscriptionSubscriptionPayloadPromise
  extends Promise<TranscriptionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TranscriptionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TranscriptionPreviousValuesPromise>() => T;
}

export interface TranscriptionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TranscriptionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TranscriptionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TranscriptionPreviousValuesSubscription>() => T;
}

export interface TrunkedCallFrequencyTimeConnection {
  pageInfo: PageInfo;
  edges: TrunkedCallFrequencyTimeEdge[];
}

export interface TrunkedCallFrequencyTimeConnectionPromise
  extends Promise<TrunkedCallFrequencyTimeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TrunkedCallFrequencyTimeEdge>>() => T;
  aggregate: <T = AggregateTrunkedCallFrequencyTimePromise>() => T;
}

export interface TrunkedCallFrequencyTimeConnectionSubscription
  extends Promise<AsyncIterator<TrunkedCallFrequencyTimeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<TrunkedCallFrequencyTimeEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateTrunkedCallFrequencyTimeSubscription>() => T;
}

export interface TranscriptionPreviousValues {
  id: ID_Output;
  languageModel: String;
  beta: Float;
  body: String;
  duration: Float;
  alpha: Float;
}

export interface TranscriptionPreviousValuesPromise
  extends Promise<TranscriptionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  languageModel: () => Promise<String>;
  beta: () => Promise<Float>;
  body: () => Promise<String>;
  duration: () => Promise<Float>;
  alpha: () => Promise<Float>;
}

export interface TranscriptionPreviousValuesSubscription
  extends Promise<AsyncIterator<TranscriptionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  languageModel: () => Promise<AsyncIterator<String>>;
  beta: () => Promise<AsyncIterator<Float>>;
  body: () => Promise<AsyncIterator<String>>;
  duration: () => Promise<AsyncIterator<Float>>;
  alpha: () => Promise<AsyncIterator<Float>>;
}

export interface TrunkedCallEdge {
  node: TrunkedCall;
  cursor: String;
}

export interface TrunkedCallEdgePromise
  extends Promise<TrunkedCallEdge>,
    Fragmentable {
  node: <T = TrunkedCallPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TrunkedCallEdgeSubscription
  extends Promise<AsyncIterator<TrunkedCallEdge>>,
    Fragmentable {
  node: <T = TrunkedCallSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface TrunkedSystemSubscriptionPayload {
  mutation: MutationType;
  node: TrunkedSystem;
  updatedFields: String[];
  previousValues: TrunkedSystemPreviousValues;
}

export interface TrunkedSystemSubscriptionPayloadPromise
  extends Promise<TrunkedSystemSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TrunkedSystemPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TrunkedSystemPreviousValuesPromise>() => T;
}

export interface TrunkedSystemSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TrunkedSystemSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TrunkedSystemSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TrunkedSystemPreviousValuesSubscription>() => T;
}

export interface AggregateTranscriptionWord {
  count: Int;
}

export interface AggregateTranscriptionWordPromise
  extends Promise<AggregateTranscriptionWord>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTranscriptionWordSubscription
  extends Promise<AsyncIterator<AggregateTranscriptionWord>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TranscriptionWordSubscriptionPayload {
  mutation: MutationType;
  node: TranscriptionWord;
  updatedFields: String[];
  previousValues: TranscriptionWordPreviousValues;
}

export interface TranscriptionWordSubscriptionPayloadPromise
  extends Promise<TranscriptionWordSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TranscriptionWordPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TranscriptionWordPreviousValuesPromise>() => T;
}

export interface TranscriptionWordSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TranscriptionWordSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TranscriptionWordSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TranscriptionWordPreviousValuesSubscription>() => T;
}

export interface TranscriptionWordConnection {
  pageInfo: PageInfo;
  edges: TranscriptionWordEdge[];
}

export interface TranscriptionWordConnectionPromise
  extends Promise<TranscriptionWordConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TranscriptionWordEdge>>() => T;
  aggregate: <T = AggregateTranscriptionWordPromise>() => T;
}

export interface TranscriptionWordConnectionSubscription
  extends Promise<AsyncIterator<TranscriptionWordConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TranscriptionWordEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTranscriptionWordSubscription>() => T;
}

export interface TranscriptionWordPreviousValues {
  id: ID_Output;
  text: String;
  confidence: Float;
  end: Int;
  start: Int;
}

export interface TranscriptionWordPreviousValuesPromise
  extends Promise<TranscriptionWordPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  text: () => Promise<String>;
  confidence: () => Promise<Float>;
  end: () => Promise<Int>;
  start: () => Promise<Int>;
}

export interface TranscriptionWordPreviousValuesSubscription
  extends Promise<AsyncIterator<TranscriptionWordPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  text: () => Promise<AsyncIterator<String>>;
  confidence: () => Promise<AsyncIterator<Float>>;
  end: () => Promise<AsyncIterator<Int>>;
  start: () => Promise<AsyncIterator<Int>>;
}

export interface TranscriptionEdge {
  node: Transcription;
  cursor: String;
}

export interface TranscriptionEdgePromise
  extends Promise<TranscriptionEdge>,
    Fragmentable {
  node: <T = TranscriptionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TranscriptionEdgeSubscription
  extends Promise<AsyncIterator<TranscriptionEdge>>,
    Fragmentable {
  node: <T = TranscriptionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface TrunkedCall {
  id: ID_Output;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
  frequency: Int;
  startTime: DateTimeOutput;
  endTime: DateTimeOutput;
  emergency?: Boolean;
  duration?: Float;
  source?: Int;
  audioPath?: String;
  callHash?: String;
  wavPath?: String;
  remotePath?: String;
}

export interface TrunkedCallPromise extends Promise<TrunkedCall>, Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  frequency: () => Promise<Int>;
  startTime: () => Promise<DateTimeOutput>;
  endTime: () => Promise<DateTimeOutput>;
  emergency: () => Promise<Boolean>;
  talkgroup: <T = TrunkedTalkgroupPromise>() => T;
  system: <T = TrunkedSystemPromise>() => T;
  sources: <T = FragmentableArray<TrunkedCallSource>>(args?: {
    where?: TrunkedCallSourceWhereInput;
    orderBy?: TrunkedCallSourceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  duration: () => Promise<Float>;
  source: () => Promise<Int>;
  audioPath: () => Promise<String>;
  frequencyList: <T = FragmentableArray<TrunkedCallFrequencyTime>>(args?: {
    where?: TrunkedCallFrequencyTimeWhereInput;
    orderBy?: TrunkedCallFrequencyTimeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  callHash: () => Promise<String>;
  wavPath: () => Promise<String>;
  transcription: <T = TranscriptionPromise>() => T;
  remotePath: () => Promise<String>;
}

export interface TrunkedCallSubscription
  extends Promise<AsyncIterator<TrunkedCall>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  frequency: () => Promise<AsyncIterator<Int>>;
  startTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  endTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  emergency: () => Promise<AsyncIterator<Boolean>>;
  talkgroup: <T = TrunkedTalkgroupSubscription>() => T;
  system: <T = TrunkedSystemSubscription>() => T;
  sources: <T = Promise<AsyncIterator<TrunkedCallSourceSubscription>>>(args?: {
    where?: TrunkedCallSourceWhereInput;
    orderBy?: TrunkedCallSourceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  duration: () => Promise<AsyncIterator<Float>>;
  source: () => Promise<AsyncIterator<Int>>;
  audioPath: () => Promise<AsyncIterator<String>>;
  frequencyList: <
    T = Promise<AsyncIterator<TrunkedCallFrequencyTimeSubscription>>
  >(args?: {
    where?: TrunkedCallFrequencyTimeWhereInput;
    orderBy?: TrunkedCallFrequencyTimeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  callHash: () => Promise<AsyncIterator<String>>;
  wavPath: () => Promise<AsyncIterator<String>>;
  transcription: <T = TranscriptionSubscription>() => T;
  remotePath: () => Promise<AsyncIterator<String>>;
}

export interface TrunkedCallNullablePromise
  extends Promise<TrunkedCall | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  frequency: () => Promise<Int>;
  startTime: () => Promise<DateTimeOutput>;
  endTime: () => Promise<DateTimeOutput>;
  emergency: () => Promise<Boolean>;
  talkgroup: <T = TrunkedTalkgroupPromise>() => T;
  system: <T = TrunkedSystemPromise>() => T;
  sources: <T = FragmentableArray<TrunkedCallSource>>(args?: {
    where?: TrunkedCallSourceWhereInput;
    orderBy?: TrunkedCallSourceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  duration: () => Promise<Float>;
  source: () => Promise<Int>;
  audioPath: () => Promise<String>;
  frequencyList: <T = FragmentableArray<TrunkedCallFrequencyTime>>(args?: {
    where?: TrunkedCallFrequencyTimeWhereInput;
    orderBy?: TrunkedCallFrequencyTimeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  callHash: () => Promise<String>;
  wavPath: () => Promise<String>;
  transcription: <T = TranscriptionPromise>() => T;
  remotePath: () => Promise<String>;
}

export interface TrunkedSystemPreviousValues {
  id: ID_Output;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
  controlChannels: Float[];
  channels: Float[];
  type: TrunkedSystemType;
  alphatags: String[];
  recordUnknown?: Boolean;
  shortName?: String;
  uploadScript?: String;
  audioArchive?: Boolean;
  callLog?: Boolean;
  bandplan?: TrunkedSmartnetBandplan;
  bandplanBase?: Float;
  bandplanHigh?: Float;
  bandplanSpacing?: Float;
  bandplanOffset?: Float;
  talkgroupDisplayFormat?: TrunkedTalkgroupDisplayFormat;
  delayCreateOutput?: Boolean;
  hideEncrypted?: Boolean;
  hideUnknownTalkgroups?: Boolean;
}

export interface TrunkedSystemPreviousValuesPromise
  extends Promise<TrunkedSystemPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  controlChannels: () => Promise<Float[]>;
  channels: () => Promise<Float[]>;
  type: () => Promise<TrunkedSystemType>;
  alphatags: () => Promise<String[]>;
  recordUnknown: () => Promise<Boolean>;
  shortName: () => Promise<String>;
  uploadScript: () => Promise<String>;
  audioArchive: () => Promise<Boolean>;
  callLog: () => Promise<Boolean>;
  bandplan: () => Promise<TrunkedSmartnetBandplan>;
  bandplanBase: () => Promise<Float>;
  bandplanHigh: () => Promise<Float>;
  bandplanSpacing: () => Promise<Float>;
  bandplanOffset: () => Promise<Float>;
  talkgroupDisplayFormat: () => Promise<TrunkedTalkgroupDisplayFormat>;
  delayCreateOutput: () => Promise<Boolean>;
  hideEncrypted: () => Promise<Boolean>;
  hideUnknownTalkgroups: () => Promise<Boolean>;
}

export interface TrunkedSystemPreviousValuesSubscription
  extends Promise<AsyncIterator<TrunkedSystemPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  controlChannels: () => Promise<AsyncIterator<Float[]>>;
  channels: () => Promise<AsyncIterator<Float[]>>;
  type: () => Promise<AsyncIterator<TrunkedSystemType>>;
  alphatags: () => Promise<AsyncIterator<String[]>>;
  recordUnknown: () => Promise<AsyncIterator<Boolean>>;
  shortName: () => Promise<AsyncIterator<String>>;
  uploadScript: () => Promise<AsyncIterator<String>>;
  audioArchive: () => Promise<AsyncIterator<Boolean>>;
  callLog: () => Promise<AsyncIterator<Boolean>>;
  bandplan: () => Promise<AsyncIterator<TrunkedSmartnetBandplan>>;
  bandplanBase: () => Promise<AsyncIterator<Float>>;
  bandplanHigh: () => Promise<AsyncIterator<Float>>;
  bandplanSpacing: () => Promise<AsyncIterator<Float>>;
  bandplanOffset: () => Promise<AsyncIterator<Float>>;
  talkgroupDisplayFormat: () => Promise<
    AsyncIterator<TrunkedTalkgroupDisplayFormat>
  >;
  delayCreateOutput: () => Promise<AsyncIterator<Boolean>>;
  hideEncrypted: () => Promise<AsyncIterator<Boolean>>;
  hideUnknownTalkgroups: () => Promise<AsyncIterator<Boolean>>;
}

export interface TrunkedCallSubscriptionPayload {
  mutation: MutationType;
  node: TrunkedCall;
  updatedFields: String[];
  previousValues: TrunkedCallPreviousValues;
}

export interface TrunkedCallSubscriptionPayloadPromise
  extends Promise<TrunkedCallSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TrunkedCallPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TrunkedCallPreviousValuesPromise>() => T;
}

export interface TrunkedCallSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TrunkedCallSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TrunkedCallSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TrunkedCallPreviousValuesSubscription>() => T;
}

export interface AggregateTrunkedConfig {
  count: Int;
}

export interface AggregateTrunkedConfigPromise
  extends Promise<AggregateTrunkedConfig>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTrunkedConfigSubscription
  extends Promise<AsyncIterator<AggregateTrunkedConfig>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TrunkedCallPreviousValues {
  id: ID_Output;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
  frequency: Int;
  startTime: DateTimeOutput;
  endTime: DateTimeOutput;
  emergency?: Boolean;
  duration?: Float;
  source?: Int;
  audioPath?: String;
  callHash?: String;
  wavPath?: String;
  remotePath?: String;
}

export interface TrunkedCallPreviousValuesPromise
  extends Promise<TrunkedCallPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  frequency: () => Promise<Int>;
  startTime: () => Promise<DateTimeOutput>;
  endTime: () => Promise<DateTimeOutput>;
  emergency: () => Promise<Boolean>;
  duration: () => Promise<Float>;
  source: () => Promise<Int>;
  audioPath: () => Promise<String>;
  callHash: () => Promise<String>;
  wavPath: () => Promise<String>;
  remotePath: () => Promise<String>;
}

export interface TrunkedCallPreviousValuesSubscription
  extends Promise<AsyncIterator<TrunkedCallPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  frequency: () => Promise<AsyncIterator<Int>>;
  startTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  endTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  emergency: () => Promise<AsyncIterator<Boolean>>;
  duration: () => Promise<AsyncIterator<Float>>;
  source: () => Promise<AsyncIterator<Int>>;
  audioPath: () => Promise<AsyncIterator<String>>;
  callHash: () => Promise<AsyncIterator<String>>;
  wavPath: () => Promise<AsyncIterator<String>>;
  remotePath: () => Promise<AsyncIterator<String>>;
}

export interface TrunkedTalkgroupSubscriptionPayload {
  mutation: MutationType;
  node: TrunkedTalkgroup;
  updatedFields: String[];
  previousValues: TrunkedTalkgroupPreviousValues;
}

export interface TrunkedTalkgroupSubscriptionPayloadPromise
  extends Promise<TrunkedTalkgroupSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TrunkedTalkgroupPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TrunkedTalkgroupPreviousValuesPromise>() => T;
}

export interface TrunkedTalkgroupSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TrunkedTalkgroupSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TrunkedTalkgroupSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TrunkedTalkgroupPreviousValuesSubscription>() => T;
}

export interface Dump1090MessageConnection {
  pageInfo: PageInfo;
  edges: Dump1090MessageEdge[];
}

export interface Dump1090MessageConnectionPromise
  extends Promise<Dump1090MessageConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<Dump1090MessageEdge>>() => T;
  aggregate: <T = AggregateDump1090MessagePromise>() => T;
}

export interface Dump1090MessageConnectionSubscription
  extends Promise<AsyncIterator<Dump1090MessageConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<Dump1090MessageEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDump1090MessageSubscription>() => T;
}

export interface Transcription {
  id: ID_Output;
  languageModel: String;
  beta: Float;
  body: String;
  duration: Float;
  alpha: Float;
}

export interface TranscriptionPromise
  extends Promise<Transcription>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  call: <T = TrunkedCallPromise>() => T;
  languageModel: () => Promise<String>;
  beta: () => Promise<Float>;
  body: () => Promise<String>;
  words: <T = FragmentableArray<TranscriptionWord>>(args?: {
    where?: TranscriptionWordWhereInput;
    orderBy?: TranscriptionWordOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  duration: () => Promise<Float>;
  alpha: () => Promise<Float>;
}

export interface TranscriptionSubscription
  extends Promise<AsyncIterator<Transcription>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  call: <T = TrunkedCallSubscription>() => T;
  languageModel: () => Promise<AsyncIterator<String>>;
  beta: () => Promise<AsyncIterator<Float>>;
  body: () => Promise<AsyncIterator<String>>;
  words: <T = Promise<AsyncIterator<TranscriptionWordSubscription>>>(args?: {
    where?: TranscriptionWordWhereInput;
    orderBy?: TranscriptionWordOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  duration: () => Promise<AsyncIterator<Float>>;
  alpha: () => Promise<AsyncIterator<Float>>;
}

export interface TranscriptionNullablePromise
  extends Promise<Transcription | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  call: <T = TrunkedCallPromise>() => T;
  languageModel: () => Promise<String>;
  beta: () => Promise<Float>;
  body: () => Promise<String>;
  words: <T = FragmentableArray<TranscriptionWord>>(args?: {
    where?: TranscriptionWordWhereInput;
    orderBy?: TranscriptionWordOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  duration: () => Promise<Float>;
  alpha: () => Promise<Float>;
}

export interface TrunkedCallFrequencyTimeSubscriptionPayload {
  mutation: MutationType;
  node: TrunkedCallFrequencyTime;
  updatedFields: String[];
  previousValues: TrunkedCallFrequencyTimePreviousValues;
}

export interface TrunkedCallFrequencyTimeSubscriptionPayloadPromise
  extends Promise<TrunkedCallFrequencyTimeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TrunkedCallFrequencyTimePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TrunkedCallFrequencyTimePreviousValuesPromise>() => T;
}

export interface TrunkedCallFrequencyTimeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TrunkedCallFrequencyTimeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TrunkedCallFrequencyTimeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <
    T = TrunkedCallFrequencyTimePreviousValuesSubscription
  >() => T;
}

export interface TrunkedCallSourceConnection {
  pageInfo: PageInfo;
  edges: TrunkedCallSourceEdge[];
}

export interface TrunkedCallSourceConnectionPromise
  extends Promise<TrunkedCallSourceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TrunkedCallSourceEdge>>() => T;
  aggregate: <T = AggregateTrunkedCallSourcePromise>() => T;
}

export interface TrunkedCallSourceConnectionSubscription
  extends Promise<AsyncIterator<TrunkedCallSourceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TrunkedCallSourceEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTrunkedCallSourceSubscription>() => T;
}

export interface TrunkedCallFrequencyTimePreviousValues {
  id: ID_Output;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
  frequency: Int;
  time: Int;
  position: Float;
  length: Int;
  errors: Int;
  spikes: Int;
}

export interface TrunkedCallFrequencyTimePreviousValuesPromise
  extends Promise<TrunkedCallFrequencyTimePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  frequency: () => Promise<Int>;
  time: () => Promise<Int>;
  position: () => Promise<Float>;
  length: () => Promise<Int>;
  errors: () => Promise<Int>;
  spikes: () => Promise<Int>;
}

export interface TrunkedCallFrequencyTimePreviousValuesSubscription
  extends Promise<AsyncIterator<TrunkedCallFrequencyTimePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  frequency: () => Promise<AsyncIterator<Int>>;
  time: () => Promise<AsyncIterator<Int>>;
  position: () => Promise<AsyncIterator<Float>>;
  length: () => Promise<AsyncIterator<Int>>;
  errors: () => Promise<AsyncIterator<Int>>;
  spikes: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateTrunkedCall {
  count: Int;
}

export interface AggregateTrunkedCallPromise
  extends Promise<AggregateTrunkedCall>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTrunkedCallSubscription
  extends Promise<AsyncIterator<AggregateTrunkedCall>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Dump1090MessageEdge {
  node: Dump1090Message;
  cursor: String;
}

export interface Dump1090MessageEdgePromise
  extends Promise<Dump1090MessageEdge>,
    Fragmentable {
  node: <T = Dump1090MessagePromise>() => T;
  cursor: () => Promise<String>;
}

export interface Dump1090MessageEdgeSubscription
  extends Promise<AsyncIterator<Dump1090MessageEdge>>,
    Fragmentable {
  node: <T = Dump1090MessageSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface TranscriptionWordEdge {
  node: TranscriptionWord;
  cursor: String;
}

export interface TranscriptionWordEdgePromise
  extends Promise<TranscriptionWordEdge>,
    Fragmentable {
  node: <T = TranscriptionWordPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TranscriptionWordEdgeSubscription
  extends Promise<AsyncIterator<TranscriptionWordEdge>>,
    Fragmentable {
  node: <T = TranscriptionWordSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface TrunkedCallSourceSubscriptionPayload {
  mutation: MutationType;
  node: TrunkedCallSource;
  updatedFields: String[];
  previousValues: TrunkedCallSourcePreviousValues;
}

export interface TrunkedCallSourceSubscriptionPayloadPromise
  extends Promise<TrunkedCallSourceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TrunkedCallSourcePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TrunkedCallSourcePreviousValuesPromise>() => T;
}

export interface TrunkedCallSourceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TrunkedCallSourceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TrunkedCallSourceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TrunkedCallSourcePreviousValuesSubscription>() => T;
}

export interface TranscriptionConnection {
  pageInfo: PageInfo;
  edges: TranscriptionEdge[];
}

export interface TranscriptionConnectionPromise
  extends Promise<TranscriptionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TranscriptionEdge>>() => T;
  aggregate: <T = AggregateTranscriptionPromise>() => T;
}

export interface TranscriptionConnectionSubscription
  extends Promise<AsyncIterator<TranscriptionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TranscriptionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTranscriptionSubscription>() => T;
}

export interface TrunkedCallSourcePreviousValues {
  id: ID_Output;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
  sourceId?: Int;
  time?: DateTimeOutput;
  position?: Float;
}

export interface TrunkedCallSourcePreviousValuesPromise
  extends Promise<TrunkedCallSourcePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  sourceId: () => Promise<Int>;
  time: () => Promise<DateTimeOutput>;
  position: () => Promise<Float>;
}

export interface TrunkedCallSourcePreviousValuesSubscription
  extends Promise<AsyncIterator<TrunkedCallSourcePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sourceId: () => Promise<AsyncIterator<Int>>;
  time: () => Promise<AsyncIterator<DateTimeOutput>>;
  position: () => Promise<AsyncIterator<Float>>;
}

export interface TrunkedConfigConnection {
  pageInfo: PageInfo;
  edges: TrunkedConfigEdge[];
}

export interface TrunkedConfigConnectionPromise
  extends Promise<TrunkedConfigConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TrunkedConfigEdge>>() => T;
  aggregate: <T = AggregateTrunkedConfigPromise>() => T;
}

export interface TrunkedConfigConnectionSubscription
  extends Promise<AsyncIterator<TrunkedConfigConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TrunkedConfigEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTrunkedConfigSubscription>() => T;
}

export interface TrunkedSystem {
  id: ID_Output;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
  controlChannels: Float[];
  channels: Float[];
  type: TrunkedSystemType;
  alphatags: String[];
  recordUnknown?: Boolean;
  shortName?: String;
  uploadScript?: String;
  audioArchive?: Boolean;
  callLog?: Boolean;
  bandplan?: TrunkedSmartnetBandplan;
  bandplanBase?: Float;
  bandplanHigh?: Float;
  bandplanSpacing?: Float;
  bandplanOffset?: Float;
  talkgroupDisplayFormat?: TrunkedTalkgroupDisplayFormat;
  delayCreateOutput?: Boolean;
  hideEncrypted?: Boolean;
  hideUnknownTalkgroups?: Boolean;
}

export interface TrunkedSystemPromise
  extends Promise<TrunkedSystem>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  controlChannels: () => Promise<Float[]>;
  channels: () => Promise<Float[]>;
  type: () => Promise<TrunkedSystemType>;
  alphatags: () => Promise<String[]>;
  talkgroups: <T = FragmentableArray<TrunkedTalkgroup>>(args?: {
    where?: TrunkedTalkgroupWhereInput;
    orderBy?: TrunkedTalkgroupOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  recordUnknown: () => Promise<Boolean>;
  shortName: () => Promise<String>;
  uploadScript: () => Promise<String>;
  audioArchive: () => Promise<Boolean>;
  callLog: () => Promise<Boolean>;
  bandplan: () => Promise<TrunkedSmartnetBandplan>;
  bandplanBase: () => Promise<Float>;
  bandplanHigh: () => Promise<Float>;
  bandplanSpacing: () => Promise<Float>;
  bandplanOffset: () => Promise<Float>;
  talkgroupDisplayFormat: () => Promise<TrunkedTalkgroupDisplayFormat>;
  delayCreateOutput: () => Promise<Boolean>;
  hideEncrypted: () => Promise<Boolean>;
  hideUnknownTalkgroups: () => Promise<Boolean>;
  calls: <T = FragmentableArray<TrunkedCall>>(args?: {
    where?: TrunkedCallWhereInput;
    orderBy?: TrunkedCallOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface TrunkedSystemSubscription
  extends Promise<AsyncIterator<TrunkedSystem>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  controlChannels: () => Promise<AsyncIterator<Float[]>>;
  channels: () => Promise<AsyncIterator<Float[]>>;
  type: () => Promise<AsyncIterator<TrunkedSystemType>>;
  alphatags: () => Promise<AsyncIterator<String[]>>;
  talkgroups: <
    T = Promise<AsyncIterator<TrunkedTalkgroupSubscription>>
  >(args?: {
    where?: TrunkedTalkgroupWhereInput;
    orderBy?: TrunkedTalkgroupOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  recordUnknown: () => Promise<AsyncIterator<Boolean>>;
  shortName: () => Promise<AsyncIterator<String>>;
  uploadScript: () => Promise<AsyncIterator<String>>;
  audioArchive: () => Promise<AsyncIterator<Boolean>>;
  callLog: () => Promise<AsyncIterator<Boolean>>;
  bandplan: () => Promise<AsyncIterator<TrunkedSmartnetBandplan>>;
  bandplanBase: () => Promise<AsyncIterator<Float>>;
  bandplanHigh: () => Promise<AsyncIterator<Float>>;
  bandplanSpacing: () => Promise<AsyncIterator<Float>>;
  bandplanOffset: () => Promise<AsyncIterator<Float>>;
  talkgroupDisplayFormat: () => Promise<
    AsyncIterator<TrunkedTalkgroupDisplayFormat>
  >;
  delayCreateOutput: () => Promise<AsyncIterator<Boolean>>;
  hideEncrypted: () => Promise<AsyncIterator<Boolean>>;
  hideUnknownTalkgroups: () => Promise<AsyncIterator<Boolean>>;
  calls: <T = Promise<AsyncIterator<TrunkedCallSubscription>>>(args?: {
    where?: TrunkedCallWhereInput;
    orderBy?: TrunkedCallOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface TrunkedSystemNullablePromise
  extends Promise<TrunkedSystem | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  controlChannels: () => Promise<Float[]>;
  channels: () => Promise<Float[]>;
  type: () => Promise<TrunkedSystemType>;
  alphatags: () => Promise<String[]>;
  talkgroups: <T = FragmentableArray<TrunkedTalkgroup>>(args?: {
    where?: TrunkedTalkgroupWhereInput;
    orderBy?: TrunkedTalkgroupOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  recordUnknown: () => Promise<Boolean>;
  shortName: () => Promise<String>;
  uploadScript: () => Promise<String>;
  audioArchive: () => Promise<Boolean>;
  callLog: () => Promise<Boolean>;
  bandplan: () => Promise<TrunkedSmartnetBandplan>;
  bandplanBase: () => Promise<Float>;
  bandplanHigh: () => Promise<Float>;
  bandplanSpacing: () => Promise<Float>;
  bandplanOffset: () => Promise<Float>;
  talkgroupDisplayFormat: () => Promise<TrunkedTalkgroupDisplayFormat>;
  delayCreateOutput: () => Promise<Boolean>;
  hideEncrypted: () => Promise<Boolean>;
  hideUnknownTalkgroups: () => Promise<Boolean>;
  calls: <T = FragmentableArray<TrunkedCall>>(args?: {
    where?: TrunkedCallWhereInput;
    orderBy?: TrunkedCallOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface AggregateTrunkedCallSource {
  count: Int;
}

export interface AggregateTrunkedCallSourcePromise
  extends Promise<AggregateTrunkedCallSource>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTrunkedCallSourceSubscription
  extends Promise<AsyncIterator<AggregateTrunkedCallSource>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TrunkedCallConnection {
  pageInfo: PageInfo;
  edges: TrunkedCallEdge[];
}

export interface TrunkedCallConnectionPromise
  extends Promise<TrunkedCallConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TrunkedCallEdge>>() => T;
  aggregate: <T = AggregateTrunkedCallPromise>() => T;
}

export interface TrunkedCallConnectionSubscription
  extends Promise<AsyncIterator<TrunkedCallConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TrunkedCallEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTrunkedCallSubscription>() => T;
}

export interface TrunkedSourceSubscriptionPayload {
  mutation: MutationType;
  node: TrunkedSource;
  updatedFields: String[];
  previousValues: TrunkedSourcePreviousValues;
}

export interface TrunkedSourceSubscriptionPayloadPromise
  extends Promise<TrunkedSourceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TrunkedSourcePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TrunkedSourcePreviousValuesPromise>() => T;
}

export interface TrunkedSourceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TrunkedSourceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TrunkedSourceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TrunkedSourcePreviousValuesSubscription>() => T;
}

export interface TrunkedTalkgroup {
  id: ID_Output;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
  decimal: Int;
  mode?: String;
  alphaTag?: String;
  description?: String;
  tag?: String;
  group?: String;
  priority: Int;
  hash: String;
}

export interface TrunkedTalkgroupPromise
  extends Promise<TrunkedTalkgroup>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  decimal: () => Promise<Int>;
  mode: () => Promise<String>;
  alphaTag: () => Promise<String>;
  description: () => Promise<String>;
  tag: () => Promise<String>;
  group: () => Promise<String>;
  priority: () => Promise<Int>;
  system: <T = TrunkedSystemPromise>() => T;
  calls: <T = FragmentableArray<TrunkedCall>>(args?: {
    where?: TrunkedCallWhereInput;
    orderBy?: TrunkedCallOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  hash: () => Promise<String>;
}

export interface TrunkedTalkgroupSubscription
  extends Promise<AsyncIterator<TrunkedTalkgroup>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  decimal: () => Promise<AsyncIterator<Int>>;
  mode: () => Promise<AsyncIterator<String>>;
  alphaTag: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  tag: () => Promise<AsyncIterator<String>>;
  group: () => Promise<AsyncIterator<String>>;
  priority: () => Promise<AsyncIterator<Int>>;
  system: <T = TrunkedSystemSubscription>() => T;
  calls: <T = Promise<AsyncIterator<TrunkedCallSubscription>>>(args?: {
    where?: TrunkedCallWhereInput;
    orderBy?: TrunkedCallOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  hash: () => Promise<AsyncIterator<String>>;
}

export interface TrunkedTalkgroupNullablePromise
  extends Promise<TrunkedTalkgroup | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  decimal: () => Promise<Int>;
  mode: () => Promise<String>;
  alphaTag: () => Promise<String>;
  description: () => Promise<String>;
  tag: () => Promise<String>;
  group: () => Promise<String>;
  priority: () => Promise<Int>;
  system: <T = TrunkedSystemPromise>() => T;
  calls: <T = FragmentableArray<TrunkedCall>>(args?: {
    where?: TrunkedCallWhereInput;
    orderBy?: TrunkedCallOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  hash: () => Promise<String>;
}

export interface TrunkedConfigPreviousValues {
  id: ID_Output;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
  name: String;
  defaultMode: TrunkedDefaultMode;
  captureDir: String;
  callTimeout: Int;
  logFile: Boolean;
  frequencyFormat: TrunkedFrequencyFormat;
  controlWarnRate: Int;
  statusAsString: Boolean;
}

export interface TrunkedConfigPreviousValuesPromise
  extends Promise<TrunkedConfigPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  defaultMode: () => Promise<TrunkedDefaultMode>;
  captureDir: () => Promise<String>;
  callTimeout: () => Promise<Int>;
  logFile: () => Promise<Boolean>;
  frequencyFormat: () => Promise<TrunkedFrequencyFormat>;
  controlWarnRate: () => Promise<Int>;
  statusAsString: () => Promise<Boolean>;
}

export interface TrunkedConfigPreviousValuesSubscription
  extends Promise<AsyncIterator<TrunkedConfigPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  defaultMode: () => Promise<AsyncIterator<TrunkedDefaultMode>>;
  captureDir: () => Promise<AsyncIterator<String>>;
  callTimeout: () => Promise<AsyncIterator<Int>>;
  logFile: () => Promise<AsyncIterator<Boolean>>;
  frequencyFormat: () => Promise<AsyncIterator<TrunkedFrequencyFormat>>;
  controlWarnRate: () => Promise<AsyncIterator<Int>>;
  statusAsString: () => Promise<AsyncIterator<Boolean>>;
}

export interface TrunkedConfigSubscriptionPayload {
  mutation: MutationType;
  node: TrunkedConfig;
  updatedFields: String[];
  previousValues: TrunkedConfigPreviousValues;
}

export interface TrunkedConfigSubscriptionPayloadPromise
  extends Promise<TrunkedConfigSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TrunkedConfigPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TrunkedConfigPreviousValuesPromise>() => T;
}

export interface TrunkedConfigSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TrunkedConfigSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TrunkedConfigSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TrunkedConfigPreviousValuesSubscription>() => T;
}

export interface AggregateTranscription {
  count: Int;
}

export interface AggregateTranscriptionPromise
  extends Promise<AggregateTranscription>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTranscriptionSubscription
  extends Promise<AsyncIterator<AggregateTranscription>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TrunkedCallFrequencyTimeEdge {
  node: TrunkedCallFrequencyTime;
  cursor: String;
}

export interface TrunkedCallFrequencyTimeEdgePromise
  extends Promise<TrunkedCallFrequencyTimeEdge>,
    Fragmentable {
  node: <T = TrunkedCallFrequencyTimePromise>() => T;
  cursor: () => Promise<String>;
}

export interface TrunkedCallFrequencyTimeEdgeSubscription
  extends Promise<AsyncIterator<TrunkedCallFrequencyTimeEdge>>,
    Fragmentable {
  node: <T = TrunkedCallFrequencyTimeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface TrunkedSource {
  id: ID_Output;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
  center: Float;
  rate: Float;
  squelch: Float;
  error: Float;
  gain: Float;
  digitalRecorders: Float;
  digitalLevels?: Float;
  analogRecorders: Float;
  analogLevels?: Float;
  device: String;
  modulation: TrunkedModulation;
}

export interface TrunkedSourcePromise
  extends Promise<TrunkedSource>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  center: () => Promise<Float>;
  rate: () => Promise<Float>;
  squelch: () => Promise<Float>;
  error: () => Promise<Float>;
  gain: () => Promise<Float>;
  digitalRecorders: () => Promise<Float>;
  digitalLevels: () => Promise<Float>;
  analogRecorders: () => Promise<Float>;
  analogLevels: () => Promise<Float>;
  device: () => Promise<String>;
  modulation: () => Promise<TrunkedModulation>;
}

export interface TrunkedSourceSubscription
  extends Promise<AsyncIterator<TrunkedSource>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  center: () => Promise<AsyncIterator<Float>>;
  rate: () => Promise<AsyncIterator<Float>>;
  squelch: () => Promise<AsyncIterator<Float>>;
  error: () => Promise<AsyncIterator<Float>>;
  gain: () => Promise<AsyncIterator<Float>>;
  digitalRecorders: () => Promise<AsyncIterator<Float>>;
  digitalLevels: () => Promise<AsyncIterator<Float>>;
  analogRecorders: () => Promise<AsyncIterator<Float>>;
  analogLevels: () => Promise<AsyncIterator<Float>>;
  device: () => Promise<AsyncIterator<String>>;
  modulation: () => Promise<AsyncIterator<TrunkedModulation>>;
}

export interface TrunkedSourceNullablePromise
  extends Promise<TrunkedSource | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  center: () => Promise<Float>;
  rate: () => Promise<Float>;
  squelch: () => Promise<Float>;
  error: () => Promise<Float>;
  gain: () => Promise<Float>;
  digitalRecorders: () => Promise<Float>;
  digitalLevels: () => Promise<Float>;
  analogRecorders: () => Promise<Float>;
  analogLevels: () => Promise<Float>;
  device: () => Promise<String>;
  modulation: () => Promise<TrunkedModulation>;
}

export interface TrunkedSourceEdge {
  node: TrunkedSource;
  cursor: String;
}

export interface TrunkedSourceEdgePromise
  extends Promise<TrunkedSourceEdge>,
    Fragmentable {
  node: <T = TrunkedSourcePromise>() => T;
  cursor: () => Promise<String>;
}

export interface TrunkedSourceEdgeSubscription
  extends Promise<AsyncIterator<TrunkedSourceEdge>>,
    Fragmentable {
  node: <T = TrunkedSourceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Long = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).
*/
export type Float = number;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "TrunkedConfig",
    embedded: false
  },
  {
    name: "TrunkedSource",
    embedded: false
  },
  {
    name: "TrunkedSystem",
    embedded: false
  },
  {
    name: "TrunkedTalkgroup",
    embedded: false
  },
  {
    name: "TrunkedCall",
    embedded: false
  },
  {
    name: "TrunkedCallSource",
    embedded: false
  },
  {
    name: "TrunkedCallFrequencyTime",
    embedded: false
  },
  {
    name: "TrunkedModulation",
    embedded: false
  },
  {
    name: "TrunkedSystemType",
    embedded: false
  },
  {
    name: "TrunkedSmartnetBandplan",
    embedded: false
  },
  {
    name: "TrunkedTalkgroupDisplayFormat",
    embedded: false
  },
  {
    name: "TrunkedDefaultMode",
    embedded: false
  },
  {
    name: "TrunkedFrequencyFormat",
    embedded: false
  },
  {
    name: "Dump1090Message",
    embedded: false
  },
  {
    name: "Dump1090Aircraft",
    embedded: false
  },
  {
    name: "Dump1090MessageType",
    embedded: false
  },
  {
    name: "Dump1090TransmissionType",
    embedded: false
  },
  {
    name: "Transcription",
    embedded: false
  },
  {
    name: "TranscriptionWord",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `${process.env["PRISMA_ENDPOINT"]}`,
  secret: `scrapingskies`
});
export const prisma = new Prisma();
